<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/academicons-1.9.2/css/academicons.css">
<link rel="stylesheet" href="/assets/css/fontawesome-free-6.1.1-web/css/all.css">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">

<title>🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11)</title>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11) | Giseop Kim Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11)" />
<meta name="author" content="Giseop Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="도커 빌드부터 떠먹여주는 강의 미래의 나를 위해 까먹는다." />
<meta property="og:description" content="도커 빌드부터 떠먹여주는 강의 미래의 나를 위해 까먹는다." />
<link rel="canonical" href="http://localhost:4000/slam/2024/01/01/cpp17-tbb.html" />
<meta property="og:url" content="http://localhost:4000/slam/2024/01/01/cpp17-tbb.html" />
<meta property="og:site_name" content="Giseop Kim Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-01T10:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Giseop Kim"},"dateModified":"2024-01-01T10:00:00+09:00","datePublished":"2024-01-01T10:00:00+09:00","description":"도커 빌드부터 떠먹여주는 강의 미래의 나를 위해 까먹는다.","headline":"🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/slam/2024/01/01/cpp17-tbb.html"},"url":"http://localhost:4000/slam/2024/01/01/cpp17-tbb.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/assets/js/darkmode.js"></script>


<!-- fabicon -->
<link rel="icon" type="image/png" href="/assets/icon/me.png">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {
          equationNumbers: {
            autoNumber: "AMS"
          }
        },
        tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
      }
    });
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
</script>
<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    
</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header condensed">
      <div class="about-title">
      <a href="/">
        
        <img src="/assets/giseopkim_thermal.png" alt="Giseop Kim" />
        
      </a>
      <h2 id="title">
        <a href="/">Giseop Kim</a>
      </h2>
      </div><p class="tagline">SLAM Engineer</p></div>
      
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/slam/2024/01/01/cpp17-tbb.html">
    <h2 class="post-title">🌈 C++17 execution 실습 1편: 빌드부터 실행까지 (Feat. oneTBB and g++-11)</h2>
  </a>
  <hr style="border:1px foo rgb(193, 198, 200)">
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Jan 1, 2024</div><ul class="post-categories"><li>SLAM</li></ul></div>
  <div class="post">
    <h1 id="도커-빌드부터-떠먹여주는-강의">도커 빌드부터 떠먹여주는 강의</h1>
<ul>
  <li>미래의 나를 위해</li>
  <li>까먹는다.</li>
</ul>

<h2 id="c17-execution-이란">C++17 execution 이란?</h2>
<ul>
  <li><a href="https://occamsrazr.net/tt/325#fnref1:1">C++의 표준알고리즘</a>의 첫번째 인자로 병렬처리 policy (seq, unseq, par, par_unseq 중 하나) 지정해주면, 컴파일러가 알아서 멀티코어를 활용하는 실행파일을 생성해주는 문법을 의미한다.</li>
  <li>자세한 설명은 웹에 많으니 생략한다.</li>
  <li>대신 직접 실험하려면 어떻게 해야 하는지에 대한 <del>연말휴가</del>기록.</li>
</ul>

<h2 id="실습">실습</h2>
<ul>
  <li>냅다 실습해보자.
    <ul>
      <li>모든 파일들은 여기에: <a href="http://github.com/gisbi-kim/cpp17-execution-policy-practice-with-oneTBB/tree/main">C++17 execution policy practice with oneTBB</a></li>
    </ul>
  </li>
  <li>차례대로 알아보자.</li>
</ul>

<h3 id="1-모든-실습의-시작은-도커이미지-굽기-부터">1. 모든 실습의 시작은 도커이미지 굽기 부터</h3>
<ul>
  <li>후술하겠지만 gcc version 에 따라 빌드가 되기도 안되기도 한다.</li>
  <li>따라서 기본적으로 모든 실습의 기본은 환경 격리를 선호하도록 하자.</li>
  <li>도커를 활용하자.
    <ul>
      <li>도커에 대한 자세한 설명은 생략한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Dockerfile.22.04</code> 이란 이름의 파일에 다음과 같이 입력하자.
    <ul>
      <li>ps. 확장자는 있어도 되고 없어도 된다. Dockerfile 이라고 무확장자로 이름짓는 게 가장 기본적인 규칙이지만 맘대로 지어도 상관없다.
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  FROM ubuntu:22.04

  <span class="c"># 필수 패키지 설치</span>
      RUN apt-get update <span class="o">&amp;&amp;</span> <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
      build-essential <span class="se">\</span>
      g++ <span class="se">\</span>
      cmake <span class="se">\</span>
      git

  <span class="c"># 작업 디렉토리 설정</span>
  WORKDIR /usr/src/myapp
</code></pre></div>        </div>
        <ul>
          <li>추후에 몇 가지 필요한 것을 더 설치할 예정이다.
            <ul>
              <li>그것들을 원래 Dockerfile 안에 모두 기입하여 원샷으로 더 편하게 하면 좋겠지만</li>
              <li>스텝바이스텝으로 보여주기 위해 일단 가장 기본적인 내용만 구웠다.</li>
              <li>이 정도 베이스로만 구우면 빨리 구워지고 용량도 작아서 좋다. 이번 실험외에 평소에도 다양한 실험들을 깨끗하게 시작해보고 싶을 때 공통적인 미니멀한 베이스로 쓰기 좋  다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>그나저나 C++ project 를 수행할 때에는 자신의 C++ 생태계에 대해서도 잘 알아야 한다 (== C++보다 좋은 언어가 나왔다고 해서 거기로 바로 갈 수 없는 이유).
        <ul>
          <li>특히 텍스트를 바이너리로 바꿔주는 건 컴파일러(와 링커) 인 g++ 이기 때문에, <a href="https://en.cppreference.com/w/cpp/compiler_support">g++ 버전이 몇인지</a> 습관적으로 체크하도록 하자.
            <ul>
              <li>그리고 이 모든 버전들은 디폴트 조합들이 존재한다.
                <ul>
                  <li>예를 들어 위에서처럼 간단히 g++ 라고 하면 OS 버전에 따라서 디폴트 버전을 잡는 것이 다르다.
                    <ul>
                      <li><code class="language-plaintext highlighter-rouge">FROM ubuntu:22.04</code> 할 경우 (<code class="language-plaintext highlighter-rouge">g++ -v</code> 해보면) 기본적으로 11.4를 설치한다.</li>
                      <li><code class="language-plaintext highlighter-rouge">FROM ubuntu:20.04</code> 할 경우 기본적으로 9.4를 설치한다.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>터미널에서 이렇게 하면 이미지가 구워진다.
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker buildx build <span class="nt">-f</span> ./Dockerfile.22.04 <span class="nt">-t</span> cpp-experiment:22.04 <span class="nb">.</span>
</code></pre></div>    </div>
    <ul>
      <li>마지막에 <code class="language-plaintext highlighter-rouge">.</code> 은 Dockerfile.22.04 이란게 현재 디렉토리에 있음을 의미한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$ docker images</code>라고 하면 구워진 이미지를 볼 수 있다.
    <ul>
      <li>예시
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  REPOSITORY         TAG          IMAGE ID       CREATED         SIZE
  cpp-experiment     22.04        f5621b4b7d84   10 hours ago    1.24GB
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-도커-컨테이너-띄우기">2. 도커 컨테이너 띄우기</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">docker run</code> 어쩌구 하면 도커 이미지로부터 컨테이너를 인스턴스화 할 수 있다.</li>
  <li>근데 뒤에 붙는 argument들을 매번 치는 게 귀찮기 때문에 스크립트화 하자.
    <ul>
      <li>예를 들어서, <code class="language-plaintext highlighter-rouge">run_tbb.22.04.sh</code>라고 하고 다음과 같이 써준다.
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">echo </span>Using 0 to <span class="nv">$1</span> cores 

  docker run <span class="nt">-ti</span> <span class="nt">--rm</span> <span class="se">\</span>
      <span class="nt">--cpuset-cpus</span><span class="o">=</span><span class="s2">"0-</span><span class="nv">$1</span><span class="s2">"</span> <span class="se">\</span>
      <span class="nt">--name</span> my-running-app-2204 <span class="se">\</span>
      <span class="nt">-v</span> <span class="nv">$PWD</span>:/usr/src/myapp <span class="se">\</span>
      cpp-experiment:22.04 <span class="se">\</span>
      bash
</code></pre></div>        </div>
        <ul>
          <li>이번 실험 (후술) 에서 코어 개수에 따른 성능차이를 보기 위해 이렇게 편하게 받도록 하였다. 터미널에서 <code class="language-plaintext highlighter-rouge">$ ./run_tbb.22.04.sh 5</code> 이런식으로 두번째 인자로 숫자를 준다. 5라고 하면 0번 코어부터 5번코어까지 사용한다는 뜻이다.</li>
          <li>docker run 할 때 <code class="language-plaintext highlighter-rouge">--cpuset-cpus</code> 옵션을 주면 컨테이너에 할당할 호스트 CPU를 명시적으로 지정해줄 수 있다. 즉 라이브러리 환경의 격리뿐 아니라 자원의 격리를 세팅해줄 수도 있다.</li>
        </ul>
      </li>
      <li>그래서 현재 폴더에 이런것들이 있을 때,
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ╰─<span class="nv">$ </span><span class="nb">pwd</span>    
  /home/gskim/Documents/cpp17execution/blog

  ╰─<span class="nv">$ </span><span class="nb">ls
  </span>Dockerfile.22.04  main.cpp  run_tbb.22.04.sh
</code></pre></div>        </div>
      </li>
      <li>터미널에서 이 위치에서, <code class="language-plaintext highlighter-rouge">$ chmod +x run_tbb.22.04.sh</code> 한 다음에 <code class="language-plaintext highlighter-rouge">$ run_tbb.22.04.sh 3</code> 이렇게 해주면 CPU 코어 개수를 제한하여 도커 컨테이너 터미널 속으로 들어갈 수 있다.
        <ul>
          <li>도커빌드할 때 <code class="language-plaintext highlighter-rouge">WORKDIR /usr/src/myapp</code>라고 지정했기 때문에, 도커 컨테이너 터미널로 들어가면 바로  /usr/src/myapp 라는 위치에 존재하게 된다. 그래서 편의상, <code class="language-plaintext highlighter-rouge">-v $PWD:/usr/src/myapp</code>라고 해서, 소스코드가 있는 현재 호스트의 디렉토리를 도커이미지의 /usr/src/myapp 에 마운트해주었다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-빌드-및-실행-1차시도">3. 빌드 및 실행: 1차시도</h3>
<ul>
  <li>위 경로에 있는 실험파일인 <code class="language-plaintext highlighter-rouge">main.cpp</code>는 다음과 같다.
    <ul>
      <li>이 코드는 내가 짠 것은 아니고 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag#Example">cppreference</a>에 있는 것을 거의 그대로 가져온 것이다.
        <ul>
          <li>이유: 가장 기본적인 실습에는 항상 변인이 통제되면 좋기 때문이다 (즉, 세팅은 모두 제대로 했지만 내가 직접 짠 코드에 존재하는 결함으로 병렬실행실험이 제대로 안될 수도 있으므로).</li>
        </ul>

        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
  <span class="cp">#ifdef PARALLEL
</span>  <span class="c1">// clang-format off</span>
  <span class="cp">#include</span> <span class="cpf">&lt;execution&gt;</span><span class="cp">
</span>  <span class="c1">// clang-format on</span>
  <span class="k">namespace</span> <span class="n">execution</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="p">;</span>
  <span class="cp">#else
</span>  <span class="k">enum</span> <span class="k">class</span> <span class="nc">execution</span> <span class="p">{</span> <span class="n">seq</span><span class="p">,</span> <span class="n">unseq</span><span class="p">,</span> <span class="n">par_unseq</span><span class="p">,</span> <span class="n">par</span> <span class="p">};</span>
  <span class="cp">#endif
</span>
  <span class="kt">void</span> <span class="nf">measure</span><span class="p">([[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="k">auto</span> <span class="n">policy</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">policy_name</span><span class="p">,</span>
               <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
  <span class="cp">#ifdef PARALLEL
</span>      <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="cp">#else
</span>      <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="cp">#endif
</span>      <span class="k">const</span> <span class="k">auto</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
      <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span>
          <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">policy_name</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" milliseconds"</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1'000'000</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">gen</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}()};</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>

  <span class="cp">#ifdef PARALLEL
</span>      <span class="n">measure</span><span class="p">(</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span> <span class="s">"seq      "</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
      <span class="n">measure</span><span class="p">(</span><span class="n">execution</span><span class="o">::</span><span class="n">unseq</span><span class="p">,</span> <span class="s">"unseq    "</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
      <span class="n">measure</span><span class="p">(</span><span class="n">execution</span><span class="o">::</span><span class="n">par_unseq</span><span class="p">,</span> <span class="s">"par_unseq"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
      <span class="n">measure</span><span class="p">(</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="s">"par      "</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="cp">#else
</span>      <span class="n">measure</span><span class="p">(</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span> <span class="s">"No execution policy"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="cp">#endif
</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>일단 모든 코어를 다 사용했을 때 얼마나 성능이득이 있는지 확인하자
    <ul>
      <li>core 20개 짜리인 i7-13700H 에서 테스트 하였다.</li>
      <li>19 라고 해서 0번부터 19번 코어까지 다 할당해보자.
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>run_tbb.22.04.sh 19
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li><strong>1차시도-1 (no par)</strong>
    <ul>
      <li>일단 시도1에서는 의도적으로 빌드할 때 <code class="language-plaintext highlighter-rouge">-DPARALLEL</code> option 을 인자로 주지 않아 본다 (위 코드의 #ifdef 블록 참고).
        <ul>
          <li>때문에 아마 성능 이득이 없을 것이다.</li>
        </ul>
      </li>
      <li><strong>1차시도 1a: no par no opt</strong>
        <ul>
          <li>방금 19개 코어를 할당하여 들어온 도커 컨테이너 속 터미널에서 이렇게 입력해서 빌드해주자.
            <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>g++ <span class="nt">-std</span><span class="o">=</span>c++20 main.cpp <span class="nt">-o</span> main
</code></pre></div>            </div>
            <ul>
              <li>ps: <a href="https://www.modernescpp.com/index.php/thebigfour/">cpp20부터 도입</a> 된 <a href="https://corecppil.github.io/Meetups/CoreCpp2021/PavelYosifovich_Cpp20TheBigFour.pdf">‘The big four’</a> 중 하나인 <code class="language-plaintext highlighter-rouge">range</code> 를 활용하고 있어서 c++20 으로 빌드해주었다.</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">$ ./main</code> 해서 실행 (3번) 해주면 이런 결과가 나왔다.
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 479 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 460 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 529 milliseconds
</code></pre></div>            </div>
          </li>
          <li>그런데 마이크로벤치마크 할 때 -O3 를 넣지 않고 하는 것은 의미없다.</li>
        </ul>
      </li>
      <li><strong>1차시도 1b: no par (O3 opt as default)</strong>
        <ul>
          <li>다음과 같이 다시 빌드해서 실행해보자.
            <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>g++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-O3</span> main.cpp <span class="nt">-o</span> main
</code></pre></div>            </div>
          </li>
          <li><code class="language-plaintext highlighter-rouge">$ ./main</code> 해서 실행 (3번) 해주면 이런 결과가 나왔다.
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 170 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 156 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  No execution policy: 144 milliseconds
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>이로부터 우리는 다음과 같은 사실을 알 수 있다.
        <ol>
          <li>일단 당연히 컴파일러최적화 (O3) 는 걸어주어야 한다.</li>
          <li>병렬처리 하지 않으면 저정도 나온다. (베이스라인 확보)
            <ul>
              <li>물론 n 마다, 머신마다 다르기 때문에 항상 자기 머신에서 측정한 결과로만 말해야 한다.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>1차시도-2 (par)</strong>
    <ul>
      <li>이제 베이스라인 실험결과가 확보되었기 때문에 병렬처리 결과를 얻어보자.
        <ul>
          <li>ps. O3 는 항상 걸어준다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-DPARALLEL</code> 인자를 넣어서 빌드한다.
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>g++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-O3</span> main.cpp <span class="nt">-DPARALLEL</span> <span class="nt">-o</span> main
</code></pre></div>        </div>
      </li>
      <li>마찬가지로 3번 정도 실행해보면
        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  root@82b404f8eac1:/usr/src/myapp# ./main 
  seq      : 135 milliseconds
  unseq    : 142 milliseconds
  par_unseq: 164 milliseconds
  par      : 148 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  seq      : 153 milliseconds
  unseq    : 151 milliseconds
  par_unseq: 131 milliseconds
  par      : 129 milliseconds

  root@82b404f8eac1:/usr/src/myapp# ./main 
  seq      : 146 milliseconds
  unseq    : 136 milliseconds
  par_unseq: 132 milliseconds
  par      : 144 milliseconds
</code></pre></div>        </div>
      </li>
      <li>❓❓❓
        <ul>
          <li>전혀 병렬처리가 안되고 있음을 알 수 있다.</li>
        </ul>
      </li>
      <li>앞서 원래 코드예시였던 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag#Example">cppreference</a> 에 단서가 있을 지 다시 가보자.
        <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/ref.png" width="800" />
  </p>
      </li>
      <li>아하
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-ltbb</code> 와 같이 tbb 를 링크해주어야 한다.
            <ul>
              <li>gcc는 (저 예제에서는 gcc13을 사용하고 있음) c++17 execution policy의 text code를 binary로 변환하기 위해 내부적으로는 tbb를 사용하고 있는 듯하다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-ltbb</code>라고 넣어서 빌드를 시도하면, 즉:
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>g++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-O3</span> main.cpp <span class="nt">-DPARALLEL</span> <span class="nt">-ltbb</span> <span class="nt">-o</span> main
</code></pre></div>        </div>
      </li>
      <li>이렇게 못찾겠다고 링크 에러가 뜬다.
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /usr/bin/ld: cannot find <span class="nt">-ltbb</span>: No such file or directory
  collect2: error: ld returned 1 <span class="nb">exit </span>status
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h3 id="4-2차시도-tbb-라이브러리-설치">4. 2차시도: TBB 라이브러리 설치</h3>
<ul>
  <li>tbb 를 따로 설치를 해주어야 한다는 것을 알 수 있다.</li>
</ul>

<ol>
  <li><strong>방법 1: apt-get 이용</strong>
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>apt-get <span class="nb">install </span>libtbb-dev
</code></pre></div>    </div>
    <ul>
      <li>이렇게 하면 이 글 작성 기준, 버전은
        <ul>
          <li>20.04 에서는 libtbb-dev is already the newest version (2020.1-2) 가</li>
          <li>22.04 에서는 libtbb-dev is already the newest version (2021.5.0-7ubuntu2) 가 기본으로 설치된다.</li>
        </ul>
      </li>
      <li>확인 방법
        <ul>
          <li>위의 apt-get install 설치 후 해당 명령어를 한번 더 입력하면 위와 같이 출력이 나오고,</li>
          <li>혹은 코드 상에서 <code class="language-plaintext highlighter-rouge">/* #include &lt;tbb/tbb.h&gt; */ std::cout &lt;&lt; "TBB Version: " &lt;&lt; TBB_VERSION_MAJOR &lt;&lt; "." &lt;&lt; TBB_VERSION_MINOR &lt;&lt; std::endl;</code> 와 같이 해주어도 버전을 볼 수 있겠다.</li>
        </ul>
      </li>
      <li>첨언
        <ul>
          <li>굳이 (이제 2024년에) Ubuntu 18.04 에서 하는 것을 추천하지는 않는다.
            <ul>
              <li><a href="https://github.com/gaoxiang12/slam_in_autonomous_driving/blob/fe9c79bf03cffb4b9e6388015a42c747c318a182/cmake/packages.cmake#L73">뭔가 이것을 시도하는 사람들의 노력이 눈물겹다</a>.</li>
            </ul>
          </li>
          <li>그나저나  <a href="https://github.com/oneapi-src/oneTBB/releases?page=2">tbb release notes</a> 를 보면 2020년 초 이름이 Threading Building Blocks 에서 oneTBB 로 변경되었다. 그 사이 호환성 문제도 있을까?
            <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/name-change.png" width="1000" />
  </p>
            <ul>
              <li>암튼 그 이유는 공식 리드미에 따르면 에코시스템에 편입됨 어쩌구
                <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/name-reason.png" width="800" />
  </p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>방법 2: 직접 빌드</strong>
    <ul>
      <li><a href="https://github.com/oneapi-src/oneTBB/blob/master/INSTALL.md">공식 깃허브 리드미</a> 를 참고해서 빌드해주면 된다.
        <ul>
          <li>직접 빌드할 때의 장점은 특정 버전을 콕 집어서 사용해줄 수 있다는 것이다.</li>
        </ul>
      </li>
      <li>빌드 및 라이브러리 설치과정을 하나하나 다 적어보자면
        <ul>
          <li>일단 <code class="language-plaintext highlighter-rouge">$ run_tbb.22.04.sh 19</code> 해서 도커 컨테이너로 들어온다.
            <ul>
              <li>19는 대충 맥스 코어 숫자 (현재 예시에서는 20개 코어 CPU사용 중이므로). 각자 머신에 맞게 하면 된다. oneTBB library를 빌드 할 때 빠르게 빌드하려면 -j option을 주어야 하는데 이를 위해 코어를 많이 물고 들어가야 한다.</li>
            </ul>
          </li>
          <li>그 다음부터 아래처럼 해주자.
            <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>git clone https://github.com/oneapi-src/oneTBB
  <span class="nv">$ </span><span class="nb">cd </span>oneTBB
  <span class="nv">$ </span><span class="nb">mkdir </span>build 
  <span class="nv">$ </span>cmake <span class="nt">-DTBB_TEST</span><span class="o">=</span>OFF .. // test까지 빌드할 필요는 없다. 이걸 빌드하고 있으면 시간이 매우 오래  걸린다.
  <span class="nv">$ </span>cmake <span class="nt">--build</span> <span class="nb">.</span> <span class="nt">-j</span>
  <span class="nv">$ </span>cmake <span class="nt">--install</span> <span class="nb">.</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>현재 이 글을 작성하고 있는 시점에서 git clone 해서 master branch의 최신을 당겨왔더니 TBB Version: 2021.12 로 출력되었다.
        <ul>
          <li>참고로 앞서 ubuntu22.04 를 베이스이미지로 해서, 디폴트로 apt-get install 로 설치된 것의 버전은 TBB Version: 2021.5 였다.</li>
        </ul>
      </li>
      <li>사용하는 입장에서 그 차이를 느낄 기능을 쓰고 있지는 않지만, 직접 빌드해보는 실습을 해보았다.</li>
      <li>첨언
        <ul>
          <li>ubuntu20.04 를 베이스이미지로 해서 master branch의 최신을 당겨와서 (즉, TBB Version: 2021.12) 직접 소스코드를 빌드하려고 하면 컴파일 에러들이 나타난다.
            <ul>
              <li>ubuntu20.04 에서 apt-get install g++ 하면 기본적으로  version 9.4 가 설치되는데 이게 최신 oneTBB 를 빌드할 수 없는 듯 하다.
                <ul>
                  <li>g++ 버전을 11로 강제로 업그레이드 해주고 빌드를 수행하니 최신 TBB버전을 빌드할 수 있었다.
                    <ul>
                      <li>이런 조합은 검색해도 잘 안나오기 때문에 코드가 문제가 있나라고 잘못 의심하느라 시간을 많이 낭비할 수 있다. 컴파일러 버전 호환성도 늘 의심해보자. 그리고 몇 개 조합을 직접 수행해서 되는 조합을 실험적으로 찾고 기록하자.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>설치확인
    <ul>
      <li>이렇게 하면 tbb가 어디에 어떻게 설치되었는지 확인해볼 수 있다.
        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>find /usr/include /usr/local/include <span class="nt">-name</span> <span class="s1">'*tbb*'</span>
</code></pre></div>        </div>
        <ul>
          <li>tip. <a href="https://github.com/sharkdp/bat">bat이라고 cat보다 좋은 툴</a>이 있는데 이거 설치 후 <code class="language-plaintext highlighter-rouge">$ batcat [파일명]</code> 과 같이 입력하면 터미널에서 파일을 볼 때 좀 더 편안하고 예쁘게 볼 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="5-application-빌드">5. Application 빌드</h3>
<ul>
  <li>앞서 ubuntu 22.04 기준,
    <ul>
      <li>g++ version 11.4 를 이용해서,</li>
      <li>TBB (oneTBB) version 2021.5 혹은 2021.12 를 무사히 설치하였다.
        <ul>
          <li>ps. 이렇게 설치한 변경점들을 안 날려먹기 위해서는 <code class="language-plaintext highlighter-rouge">docker commit [컨테이너이름] [이미지이름:태그]</code> 해주어야 저장이 된다.
            <ul>
              <li>혹은 이런 설치과정들을 위의 Dockerfile 파일에 모두 합쳐두는 게 좋다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이것은 라이브러리를 빌드 및 설치 한 것이고,</li>
  <li>이제 우리의 어플리케이션을 빌드 및 실행해보자.</li>
</ul>

<ol>
  <li><strong>방법 1: 스크립트로 빌드</strong>
    <ul>
      <li>앞서 얘기했듯, 이렇게 하면 한줄컷이다.
        <ul>
          <li>도커 컨테이너 안으로 들어온 다음,
            <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>g++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-O3</span> main.cpp <span class="nt">-DPARALLEL</span> <span class="nt">-ltbb</span> <span class="nt">-o</span> main
</code></pre></div>            </div>
          </li>
          <li>ps. g++ version 9 에서는 c++20이라고 하면 못알아 듣고 c++2a 라고 해야 알아 듣는다.</li>
        </ul>
      </li>
      <li>그러면 바이너리가 생성되고 <code class="language-plaintext highlighter-rouge">$ ./main</code> 이라고 하면 실행된다.</li>
    </ul>
  </li>
  <li><strong>방법 2: cmake 기반 빌드</strong>
    <ul>
      <li>사실 파일 하나 짜리 프로젝트가 (당연히) 아닐 때에는, 이게 정석이다.</li>
      <li>cmake 같은 게 (CMakeLists.txt 파일 작성하는 게) 따로 시간내서 공부하기 되게 귀찮고 까다로운데</li>
      <li>ChatGPT4 시대가 오면서 해피해졌다. ‘해 줘’ 라고 하면 이렇게 해준다.
        <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/cmake.png" width="700" />
  </p>
      </li>
      <li>물론 사용자가 검증은 해야겠지만, 경험적으로 이런 work은 대체로 잘 한다.</li>
      <li>저렇게 CMakeLists.txt 파일을 작성한 뒤 하던대로 하면 되겠다.
        <ul>
          <li>즉, 도커 컨테이너 안으로 들어온 다음,
            <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">mkdir </span>build 
  <span class="nv">$ </span><span class="nb">cd </span>build 
  <span class="nv">$ </span>cmake ..
  <span class="nv">$ </span>make <span class="nt">-j</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>그러면 바이너리가 생성되고 <code class="language-plaintext highlighter-rouge">$ ./main</code> 이라고 하면 실행된다.</li>
    </ul>
  </li>
</ol>

<h3 id="6-실행-결과">6. 실행 결과</h3>
<ul>
  <li>이제 병렬처리가 잘 된다. 5번 실행해보면 일관되게 <code class="language-plaintext highlighter-rouge">par</code> 사용 시 개선이 있음 (코어 20개 사용) 을 알 수 있다.
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  root@65461ff9d981:/usr/src/myapp/build# ./main 

  seq      : 147 milliseconds
  unseq    : 145 milliseconds
  par_unseq: 24 milliseconds
  par      : 24 milliseconds

  root@65461ff9d981:/usr/src/myapp/build# ./main 
  seq      : 138 milliseconds
  unseq    : 131 milliseconds
  par_unseq: 20 milliseconds
  par      : 21 milliseconds

  root@65461ff9d981:/usr/src/myapp/build# ./main 
  seq      : 146 milliseconds
  unseq    : 136 milliseconds
  par_unseq: 22 milliseconds
  par      : 21 milliseconds

  root@65461ff9d981:/usr/src/myapp/build# ./main 
  seq      : 132 milliseconds
  unseq    : 132 milliseconds
  par_unseq: 20 milliseconds
  par      : 21 milliseconds

  root@65461ff9d981:/usr/src/myapp/build# ./main 
  seq      : 129 milliseconds
  unseq    : 129 milliseconds
  par_unseq: 22 milliseconds
  par      : 25 milliseconds
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="7-1-ablation-1-core-수-달리해보며">7-1. Ablation 1: core 수 달리해보며</h3>
<ul>
  <li>그럼 이제 코어수를 1개부터 20개까지 달리해가며 실험해보자.
    <ul>
      <li>실험 환경은 i7-13700H</li>
    </ul>
  </li>
  <li>근데 매번 도커 컨테이너 들어갔다가 빌드 새로 했다가 나왔다가 하기 귀찮으니 자동화 해보자</li>
  <li>먼저 실험 한 번의 수행을 하나의 스크립트화를 한다.
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker run <span class="nt">-ti</span> <span class="nt">--rm</span> <span class="se">\</span>
      <span class="nt">--cpuset-cpus</span><span class="o">=</span><span class="s2">"0-</span><span class="nv">$1</span><span class="s2">"</span> <span class="se">\</span>
      <span class="nt">--name</span> my-running-app-2204 <span class="se">\</span>
      <span class="nt">-v</span> <span class="nv">$PWD</span>:/usr/src/myapp <span class="se">\</span>
      cpp-experiment:22.04 <span class="se">\</span>
      /bin/bash <span class="nt">-c</span> <span class="s2">"cd /usr/src/myapp/build &amp;&amp; </span><span class="se">\</span><span class="s2">
          rm -rf * &amp;&amp; </span><span class="se">\</span><span class="s2">
          cmake .. &amp;&amp; </span><span class="se">\</span><span class="s2">
          make -j</span><span class="nv">$num_cores</span><span class="s2"> &amp;&amp; </span><span class="se">\</span><span class="s2">
          ./main"</span>

  <span class="nb">echo</span> <span class="s2">""</span>
  <span class="nb">echo </span>We used 0 to <span class="nv">$1</span> cores 
</code></pre></div>    </div>
    <ul>
      <li>이렇게 하면 도커컨테이너 진입 후 bash 터미널에서 대기하는 것이 아니라 main을 빌드하고 실행하고 종료하고 빠져나온다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">--rm</code> 옵션을 주었기 때문에 컨테이너는 할일을 다하고 종료 후 삭제된다.</li>
        </ul>
      </li>
      <li>이 스크립트를 <code class="language-plaintext highlighter-rouge">run_tbb.22.04_auto.sh</code> 라고 하자.</li>
    </ul>
  </li>
  <li>그 다음 이렇게 한다음 이걸 실행하고 커피한모금 마시고 오면 된다.
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c">#!/bin/bash</span>

  <span class="c"># 0부터 19까지 반복</span>
  <span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..19<span class="o">}</span>
  <span class="k">do
      </span><span class="nb">echo</span> <span class="s2">"Running with 0 to </span><span class="nv">$i</span><span class="s2"> cores"</span>
      ./run_tbb.22.04_auto.sh <span class="nv">$i</span>
      <span class="nb">echo</span> <span class="s2">""</span>
  <span class="k">done</span>
</code></pre></div>    </div>
  </li>
  <li>그 다음 terminal 에 출력된 텍스트 결과물을 대충 복사해서 ChatGPT에게 그려줘라고 말하면
    <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/benchmark1.png" width="800" />
  </p>
    <ul>
      <li>해석
        <ul>
          <li>note: 일단 각 가로축 데이터포인트마다 여러번 실행해서 평균낸게 아니라 한번만 실행했기 때문에 + 다른 프로세스도 많이 돌고 있는 상태에서 그냥 실행했기 때문에 노이즈가 있을 수 있다 (예: x=19).</li>
          <li>전체적인 경향만 보면 그래도 확연히 보인다.</li>
          <li>par 이득이 확실히 있었다.</li>
          <li>unseq (검정) 은 seq에 비해 대충 plot이 아래에 경향이 위치하긴 하지만 비슷해보인다.
            <ul>
              <li>ps. unseq (~ simd) 자체는 single core 에서 작동하는 것으로 알고 있다. 이 태스크가 vectorized 되기에 적합한 태스크인지 아닌지는 잘 모르겠고 일단 실험적으로 이렇게 검증해보고 넘어가는 수밖에… 없지만 추후에 공부해보도록 하자.</li>
            </ul>
          </li>
          <li>코어 1개에서 2개, 3개가 될 때까지는 정직하게 n 배에 가까운 이득을 보았다.
            <ul>
              <li>물론 이는 태스크마다 다를 수 있으니 측정을 통해 판단해야 되겠다.</li>
              <li>코어를 20개 쓴다고 해서 들인 노력대비 20배의 이득이 있지는 않음을 의미한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="7-2-ablation-2-core-수-달리해보며-on-다른-예제">7-2. Ablation 2: core 수 달리해보며 on 다른 예제</h3>
<ul>
  <li>500만개 포인트의 좌표를 변환해보자.
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;execution&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;valarray&gt;</span><span class="cp">
</span>
  <span class="k">struct</span> <span class="nc">Point3D</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">coordinates</span><span class="p">;</span>

      <span class="n">Point3D</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">coordinates</span><span class="p">({</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">})</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="k">using</span> <span class="n">Matrix3x3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="n">Point3D</span> <span class="nf">applyTransformation</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3D</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Matrix3x3</span><span class="o">&amp;</span> <span class="n">rotationMatrix</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Point3D</span><span class="o">&amp;</span> <span class="n">translation</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">rotated</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">rotated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotationMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">coordinates</span><span class="p">).</span><span class="n">sum</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nf">Point3D</span><span class="p">(</span><span class="n">rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 예제 데이터: n개 3D 포인트</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3D</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">(</span><span class="mi">5'000'000</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">));</span>

      <span class="c1">// 회전 행렬 및 이동 벡터 정의</span>
      <span class="n">Matrix3x3</span> <span class="n">rotationMatrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
                                  <span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
                                  <span class="n">std</span><span class="o">::</span><span class="n">valarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}};</span>
      <span class="n">Point3D</span> <span class="nf">translation</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>

      <span class="c1">// 변환 시작 시간 측정</span>
      <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

      <span class="c1">// 모든 포인트에 대해 변환 적용</span>

      <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span> <span class="cm">/* CHANGE HERE! */</span><span class="p">,</span> 
                    <span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="p">[</span><span class="o">&amp;</span><span class="n">rotationMatrix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">translation</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">point</span> <span class="o">=</span> <span class="n">applyTransformation</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">rotationMatrix</span><span class="p">,</span>
                                                    <span class="n">translation</span><span class="p">);</span>
                    <span class="p">});</span>

      <span class="c1">// 변환 종료 시간 측정</span>
      <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

      <span class="c1">// 소요된 시간 계산 및 출력</span>
      <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span>
          <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Transformations completed in "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span> <span class="o">&lt;&lt;</span> <span class="s">" ms"</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>결과
    <p align="center">
      <img src="/assets/data/2024-01-01-cpp17-tbb/benchmark2.png" width="800" />
  </p>
    <ul>
      <li>이 실험에서는 vectorization 을 시도하는 것 (== <code class="language-plaintext highlighter-rouge">unseq</code>) 이 시간을 더 잡아먹었다.</li>
      <li><code class="language-plaintext highlighter-rouge">par</code> 사용시 역시 초반 3-4 코어 정도까지 선형적인 성능이득이 있고 이후에는 under linear 하다.</li>
    </ul>
  </li>
</ul>

<h3 id="7-3-ablation-3-다른-머신">7-3. Ablation 3: 다른 머신</h3>
<ul>
  <li>AMD Ryzen™ 5 7530U 노트북에서도 TBB가 잘 설치되었다.
    <ul>
      <li>위의 어플리케이션들에서 성능 이득을 역시 관찰할 수 있었다.</li>
    </ul>
  </li>
</ul>

<h2 id="결론">결론</h2>
<ul>
  <li>C++17에 도입된 execution policy는 c++ 의 functional 한 algorithm에 결합하여 사용하기 좋다.
    <ul>
      <li>사용자가 들이는 코드 작성에서의 노력은 거의 없으면서 멀티코어 이득을 쉽게 챙길 수 있다.</li>
    </ul>
  </li>
  <li>(gcc의 경우) execution policy를 컴파일 하기 위해서는 tbb 라이브러리를 링크해야 한다.
    <ul>
      <li>gcc 버전과 tbb 버전을 잘 맞춰주자. 혹은 apt-get 으로 설치했더라도 gcc 와 tbb 버전이 각각 어떠한지 습관적으로 관찰하고 넘어가자.</li>
    </ul>
  </li>
  <li>그리고 이렇게 설치한 TBB 라이브러리가 실제로 잘 작동하는지 기본적인 벤치마크 테스트코드들 (위에서는 두 개를 소개) 을 직접 구성하고 실험해보았다.</li>
  <li>실습 2편에서는 oneTBB의 다른 기능들 및 병렬처리에 관한 좀 더 이론적인 부분에 대해 알아보자.</li>
</ul>


  </div>

  <hr style="border:1px foo rgb(193, 198, 200)"><div id="disqus_thread" style="margin-top:25px"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://localhost:4000/slam/2024/01/01/cpp17-tbb.html';
      this.page.identifier = 'http://localhost:4000/slam/2024/01/01/cpp17-tbb.html';
    };
    (function () {
      var d = document, s = d.createElement('script');
      s.src = 'https://robotics.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
      powered by Disqus.</a></noscript></div>

    </section>
    <footer class="condensed">
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/assets/js/darkmode.js"></script>
  
  <script src="/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/assets/js/search.js"></script>
  
</body>

</html>
