<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/academicons-1.9.2/css/academicons.css">
<link rel="stylesheet" href="/assets/css/fontawesome-free-6.1.1-web/css/all.css">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">

<title>🌈 FAST-LIO가 말 그대로 Fast 한 이유</title>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>🌈 FAST-LIO가 말 그대로 Fast 한 이유 | Giseop Kim Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="🌈 FAST-LIO가 말 그대로 Fast 한 이유" />
<meta name="author" content="Giseop Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Illustrated Fast Kalman Gain Computation Kalman Gain 계산에는 matrix inversion 이 포함되어 있다. 근데 Matrix inversion 은 비싸다. FAST-LIO의 K 계산 과정에서의 Matrix 모양을 그림으로 그려서 알아보자." />
<meta property="og:description" content="Illustrated Fast Kalman Gain Computation Kalman Gain 계산에는 matrix inversion 이 포함되어 있다. 근데 Matrix inversion 은 비싸다. FAST-LIO의 K 계산 과정에서의 Matrix 모양을 그림으로 그려서 알아보자." />
<link rel="canonical" href="http://localhost:4000/slam/2022/11/27/fastlio-gain.html" />
<meta property="og:url" content="http://localhost:4000/slam/2022/11/27/fastlio-gain.html" />
<meta property="og:site_name" content="Giseop Kim Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-27T08:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="🌈 FAST-LIO가 말 그대로 Fast 한 이유" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Giseop Kim"},"dateModified":"2022-11-27T08:00:00+09:00","datePublished":"2022-11-27T08:00:00+09:00","description":"Illustrated Fast Kalman Gain Computation Kalman Gain 계산에는 matrix inversion 이 포함되어 있다. 근데 Matrix inversion 은 비싸다. FAST-LIO의 K 계산 과정에서의 Matrix 모양을 그림으로 그려서 알아보자.","headline":"🌈 FAST-LIO가 말 그대로 Fast 한 이유","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/slam/2022/11/27/fastlio-gain.html"},"url":"http://localhost:4000/slam/2022/11/27/fastlio-gain.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/assets/js/darkmode.js"></script>


<!-- fabicon -->
<link rel="icon" type="image/png" href="/assets/icon/me.png">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {
          equationNumbers: {
            autoNumber: "AMS"
          }
        },
        tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
      }
    });
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
</script>
<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    
</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header condensed">
      <div class="about-title">
      <a href="/">
        
        <img src="/assets/giseopkim_thermal.png" alt="Giseop Kim" />
        
      </a>
      <h2 id="title">
        <a href="/">Giseop Kim</a>
      </h2>
      </div><p class="tagline">SLAM Engineer</p></div>
      
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/slam/2022/11/27/fastlio-gain.html">
    <h2 class="post-title">🌈 FAST-LIO가 말 그대로 Fast 한 이유</h2>
  </a>
  <hr style="border:1px foo rgb(193, 198, 200)">
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Nov 27, 2022</div><ul class="post-categories"><li>SLAM</li></ul></div>
  <div class="post">
    <h1 id="illustrated-fast-kalman-gain-computation">Illustrated Fast Kalman Gain Computation</h1>
<ul>
  <li>Kalman Gain 계산에는 matrix inversion 이 포함되어 있다.</li>
  <li>근데 Matrix inversion 은 비싸다.</li>
  <li>FAST-LIO의 K 계산 과정에서의 Matrix 모양을 그림으로 그려서 알아보자.</li>
</ul>

<h2 id="대상독자">대상독자</h2>
<ul>
  <li>이 포스트는 FAST-LIO (<a href="https://github.com/hku-mars/FAST_LIO">code</a>, <a href="https://arxiv.org/abs/2010.08196">paper v1</a>) 를 한 번 정도 읽어보고 돌려본 독자에게 적당합니다.</li>
</ul>

<h2 id="속도를-빠르게-하려면">속도를 빠르게 하려면?</h2>

<h3 id="일반적으로">일반적으로</h3>
<ul>
  <li>모든 geometric optimization 은 두 단계로 나뉜다고 할 수 있다.
    <ol>
      <li>Problem buildling</li>
      <li>Problem solving</li>
    </ol>
  </li>
  <li>Proboem building 은 correspondences를 찾고 constraints 를 만드는 과정, Problem solving 은 그 constraints 를 모두 (거의) 만족하는 optimal solution을 찾는 과정을 의미한다.
    <ul>
      <li>예를 들어 통상적인 least square optimization 에서
        <ul>
          <li>$A\delta x=b$ 를 Gauss-newton 으로 푸는 것이 solving 과정이고,</li>
          <li>이를 위한 $A$ matrix 자체를 만드는 일 (및 그것을 위한 모든 앞단: e.g., 이미지 전처리, 특징점 검출, 피처 추출 등)이 problem building 이라고 할 수 있을 것이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="slam에서">SLAM에서</h3>
<ul>
  <li>FAST-LIO와 같은 LiDAR(or visual)-SLAM에서는
    <ul>
      <li>map 의 entity와 query measurement 의 entity 사이의 correspondence 를 찾는 것이 buildilng,</li>
      <li>그 사이의 residual 을 최소화하는 solution을 찾는 과정이 solving 이라고 할 수 있겠다.</li>
    </ul>
  </li>
</ul>

<h3 id="fast-lio에서">FAST-LIO에서</h3>
<ul>
  <li>FAST-LIO에서는 그래서 크게 contribution이 두 가지라고 할 수 있다.
    <ul>
      <li>Geometric optimization 의 두 단계에 대하여 각각 시간개선을 위한 contributions이 있었다.
        <ol>
          <li>ikd-tree 를 통한 problem buildling 시간 개선
            <ul>
              <li>즉, map 관리를 더 빠르게 할 수 있고, map으로 부터 correspondence 를 더 빨리 retrieval 해올 수 있게 되었다.
                <ul>
                  <li>ps. 이후 <a href="https://github.com/gaoxiang12/faster-lio">faster-lio</a> 나 <a href="https://github.com/hku-mars/VoxelMap">voxel-map</a> 에서는 kd-tree 보다도 근본적으로 빠른 hash map을 제안하기도 하였다. 아무튼 이런 노력들은 모두 problem buildling 시간 단축에 기여하는 요소라고 할 수 있다.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Fast Kalman Gain computation 을 통한 problem solving 시간 개선
            <ul>
              <li>이 부분에 대해서 이 포스트에서 자세하게 설명해보고자 한다.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h2 id="the-fast-kalman-gain">The Fast Kalman Gain</h2>
<ul>
  <li>구글에서 Kalman Gain 이라고 검색해보면 (혹은 <a href="https://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf">이 자료 (2006 An Introduction to the Kalman Filter)</a>를 보라), 통상적인 Kalman Gain 은 이렇게 생겼다.
    <ul>
      <li>Slow K: $ \textbf{K} = \textbf{P}\textbf{H}^{\textbf{T}}(\textbf{H}\textbf{P}\textbf{H}^{T} + \textbf{R})^{-1}$</li>
    </ul>
  </li>
  <li>그런데 FAST-LIO에서 사용하는 Kalman Gain은 이렇게 생겼다.
    <ul>
      <li>Fast K: $ \textbf{K} = (\textbf{H}^{T}\textbf{R}^{-1}\textbf{H}+\textbf{P}^{-1})^{-1}\textbf{H}^{T}\textbf{R}^{-1}$</li>
    </ul>
  </li>
  <li>전자를 slow K, 후자를 fast K 라고 부르자.</li>
  <li>FAST-LIO 논문에 의하면 아래 유도과정에 의해 fast ver와 slow ver 는 동치라고 한다.
    <p align="center">
  <img src="/assets/data/2022-11-26-fastlio-gain/k_eq.png" width="700" />
</p>
  </li>
  <li>The slow version 으로 불리는 $\textbf{K}$는 Conventional 한 Kalman filter 의 Gain form 으로 아주 잘 알려진 형태인데, 그렇다면 지금까지 문제가 많았단걸까? 그게 아니라면, 왜 slow version $\textbf{K}$는 특히 FAST-LIO에서 slow 할 수밖에 없었을까? 왜 그럴지 알아보자.</li>
</ul>

<h3 id="matrix-illustrated-fast-kalman-gain">Matrix-illustrated Fast Kalman Gain</h3>
<ul>
  <li>Kalman gain 의 식에 있는 $\textbf{H}$는 residual 의 미분값 (jacobian) 이다. 예를 들어, visual SLAM에서, image feature 에 대해서는 reprojection error 를 주로 많이 사용한다. <a href="https://github.com/hku-mars/r2live/blob/master/paper/r2live_ral_final.pdf">r2live 의 논문 appendix</a> 에 이 식이 잘 나와있다 (eq S7 참고).</li>
  <li>하나의 residual 에 대한 $\textbf{H}$ (그래서 constraint $i$에 대한 residual 이라고 해서 $\textbf{H}_i$ 와 같이 쓸 수도 있겠고)는 항상 이런 모양이다.
    <p align="center">
  <img src="/assets/data/2022-11-26-fastlio-gain/hi.png" width="500" />
</p>
    <ul>
      <li>cost (or called error, residual) 는 정의하기 나름이다. image 의 feature point reprojection error 는 보통 x로의 diff와 y로의 offset 을 모두 측정하므로 Dim(cost)=2 가 되겠다 (<a href="https://github.com/hku-mars/r2live/blob/master/paper/r2live_ral_final.pdf">r2live 의 논문 appendix</a> 에 이 식이 잘 나와있다 (eq S7, S10 참고).</li>
      <li>한 편, Dim(state)는 우리가 알고싶은 robot 의 상태변수를 의미한다. 아주 일반적으로는 rotation 과 translation 이므로 =6 이라고 할 수 있겠다.
        <ul>
          <li>rotation은 error-state 의 경우 minimal representation (i.e., tangent vector space) 로 표현되므로 rotation 의 dimension=3, translation의 dimension=3 (xyz) 해서 6이 된다.</li>
          <li>그리고 상황에 따라 extrinsic 이나 bias 등을 포함하면 더 길어질수도(6 이상) 있다. 하지만 <a href="https://github.com/hku-mars/r2live/blob/e719ca266ab53ca8915ca4e1416152993f2a55d7/r2live/src/estimator_node.cpp#L671">r2live 코드를 보면 6으로 설정</a>되어 있는데, 그 이유는 아마도, residual 에서 어짜피 extrinsic 이나 bias 등을 고려하지 않는 경우 (상수처리하거나 아예 term이 없는 경우), 그런 state element 에 대한 Jacobian block이 0이되므로 어짜피 그 변수조절에 기여하지 않기 때문이다 (<a href="https://github.com/hku-mars/r2live/blob/master/paper/r2live_ral_final.pdf">r2live 의 논문 appendix</a> 의 식 S4 아래 H 참고).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>그런데 a single image에서 detect 되는 feature point 의 개수나, 혹은 a single lidar scan (e.g., 360 deg horizontal sweep during 0.1 sec) 에는 포인트가 하나만 있는 것이 아니다. 이미지에는 수십-수천개의 피처가 존재할 수 있으며 (이미지 사이즈마다 다르다), lidar 역시 통상적으로 수천개의 (downsampled) 피처 포인트 를 가진다. 이런 포인트 하나 하나마다 위의 residual block (i.e,. $\textbf{H}_i$ for $i=1,2,3,…,$ 수십-수천) 이 존재하게 된다.
    <ul>
      <li>이를 overdetermined system이라고 부른다.</li>
    </ul>
  </li>
  <li>따라서 the slow K: $ \textbf{K} = \textbf{P}\textbf{H}^{\textbf{T}}(\textbf{H}\textbf{P}\textbf{H}^{T} + \textbf{R})^{-1}$ 의 식 안에 존재하는 $\textbf{H}$의 모양은 아마 이렇게 생겼을 것이다.
    <p align="center">
    <img src="/assets/data/2022-11-26-fastlio-gain/h.png" width="600" />
  </p>
  </li>
  <li>이제 거의 다 왔다. The slow $\textbf{K}$ 를 계산하기 위해 우리는 $(\textbf{H}\textbf{P}\textbf{H}^{T} + \textbf{R})^{-1}$ 가 필요하다.
    <ul>
      <li>그런데 이 matrix inversion 의 비용은 얼마일까? <a href="https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Matrix_algebra">wikipedia 에 따르면</a>, $O(n^{2})$ 보다도 비싼 것을 알 수 있다.</li>
      <li>즉, 우리는 slow kalman gain 을 계산하기 위해서 $\textbf{H}\textbf{P}\textbf{H}^{T}$ 의 shape 에 제곱배 이상에 비례하는 계산 비용을 치러야 한다. 그런데 그 shape 은 적으면 (image feature의 경우) 수백, 많으면 (liar feature의 경우) 수천 수만 까지도 커질 수 있다.
        <p align="center">
  <img src="/assets/data/2022-11-26-fastlio-gain/hpht.png" width="600" />
</p>
      </li>
    </ul>
  </li>
  <li>그런데 이에 비해, FAST-LIO에서 제안한 fast kalman gain 에서 inversion해야 하는 대상의 생김새는 이러하다.
    <p align="center">
    <img src="/assets/data/2022-11-26-fastlio-gain/htrh.png" width="600" />
  </p>
  </li>
  <li>훨씬 작음을 알 수 있다!
    <ul>
      <li>slow K 에서 inverse를 수행해야 할 matrix 크기가 작게 잡아서 60x60이라고 가정하면 (i.e., $n=60$), fast K 에서 inverse 를 수행해야 할 square matrix 의 $n=6$ 대비 10배가 크다. <a href="https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Matrix_algebra">wiki 에 따르면</a> matrix inversion 의 time complexity 는 $O(n^{2.373})$ 정도이지만 어림잡아 $O(n^{2})$ 라고 하면, 100배의 시간이 더 소요될 것으로 예측해볼 수 있다.</li>
    </ul>
  </li>
  <li>과연 진짜 이만큼 느려지게 될 지 직접 실험을 통해서 알아보자.</li>
</ul>

<h3 id="실험">실험</h3>
<ol>
  <li><strong>실험 세팅</strong>
    <ul>
      <li>실험을 위해 r2live 코드를 이용하였다. 그리고 r2live github readme 에서 공개되어 있는 저자의 HKU 데이터를 사용하였다. CPU는 11th Gen Intel(R) Core(TM) i5-11400F @ 2.60GHz 을 이용하였고, 특별히 core 제한은 하지 않았다.</li>
      <li>Time cost 측정을 위해 <a href="https://github.com/gaoxiang12/faster-lio/blob/5db8e8c1b86693db0412721e6049701deaf4012e/include/utils.h#L18">Faster-lio repository에 있는 timer class</a> 를 가져왔다.</li>
      <li>그리고 conventional 한 Kalman Gain 이 구현되어 있지 않기 때문에 직접 구현해준다. 크게 어렵지 않다.</li>
    </ul>
    <ul>
      <li>r2live 는 lidar 와 visual 기반에 각각 Kalman Gain 계산하는 부분이 있다. 그 중 편의상 visual part 에 대해서만 테스트를 진행해보았다 (Kalman Filter 자체는 abstract 한 engine 이기 때문에 개념(Fast-lio가 fast kalman gain을 제안한 기여)은 동일하다).
        <ul>
          <li><a href="https://github.com/gisbi-kim/r2live/blob/859d0433f15b904239ec09424638eb35eb7339ae/r2live/src/estimator_node.cpp#L653">See this line of codes</a>. 실험코드는 다음과 같다.
            <p align="center">
  <img src="/assets/data/2022-11-26-fastlio-gain/code.png" width="800" />
</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>실험 결과</strong>
    <ul>
      <li>실험 수행 과정 및 결과는 아래 비디오에 자세하게 나와있다.
        <iframe width="728" height="410" src="https://www.youtube.com/embed/6mI744N12yQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
        <ul>
          <li>ps. 이 실험을 reproduce 해보려면:
            <ul>
              <li>docker/run 에 있는 <a href="https://github.com/gisbi-kim/r2live/blob/859d0433f15b904239ec09424638eb35eb7339ae/docker/run#L29">repository의 volume 경로</a>를 본인의 것으로 수정하길 바란다. 그리고 demo.launch 파일에서 fast version 의 kalman gain을 사용할지 말지 <a href="https://github.com/gisbi-kim/r2live/blob/859d0433f15b904239ec09424638eb35eb7339ae/r2live/launch/demo.launch#L20">boolean param 으로 조절</a>할 수 있도록 하였다. docker 를 이용해서 r2live 를 실행하는 과정에 대해서는 다른 비디오 <a href="https://youtu.be/N6Gyzu5Xnh0">&lt;Running R2Live using Docker&gt;</a> 에서 자세하게 소개하였으니 참고.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>실험 결과를 정리해보면,
        <ol>
          <li>위 데이터셋에 대해, a single image 에서 50-100 개 정도의 feature correspondences 가 나온다.</li>
          <li>fast or slow 어떤 버전의 kalman gain을 사용하든 accuracy 측면에서는 거의 동일하게 동작하는 것처럼 보인다 (TODO: 실제로 같은지 K값 찍어보기)</li>
          <li>fast version 의 kalman gain을 계산하는 시간은 <strong>0.026ms</strong> 정도가 소요된다.</li>
          <li>slow version 의 kalman gain을 계산하는 시간은 <strong>2.6ms</strong> 정도가 소요되었다. 약 100배의 시간이 소요된 셈.
            <ul>
              <li>이는 앞서 matrix inversion의 time complexity에 근거해서 유추했던 것과 유사한 magnitude of order 이다.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>Lessons</strong>
    <ul>
      <li>image feature 에 대해서, state_dim=6 이고, num_features=50-100 이면 약 10배의 size 로 근사할 수 있었고, 실제로 이의 제곱배 이상의 time cost 가 발생함을 확인하였다.</li>
      <li>그리고 lidar feature 는 보통 1000-10000개 까지도 발생한다. 현대의 3D 라이다가 주는 하나의 스캔이 수만개의 포인트를 가지고, 이를 적절히 downsampling 해서 사용한다고 하더라도 수천개의 포인트가 존재한다. 6000개(까지도 필요없을 수도 있지만 계산의 편의상)라고 가정하면 state_dim=6 에 비해 1000배의 size 를 가지는 matrix 를 inversion 해야되게 된다. 그러면 이론적으로는 최소 1000 * 1000 배의 시간이 걸릴 것이라고 예측해볼 수 있겠다. 그러면 (위와 동일한 HW기준) 0.026 * 1000 * 1000 = 26000ms = 26 sec 으로써 이제는 real-time 이 불가능하게 된다. lidar scan이 보통 10hz라고 가정하면 (실제로는 front-end를 포함해서) 0.1s 내에 update가 되어야 real-time이라고 할 수 있다.
        <ul>
          <li>TODO: 과연 그러한지 lidar 의 kalman gain에 대해서도 직접 측정 해보자.</li>
        </ul>
      </li>
      <li>그리고 또 하나 문제가 될 수 있는 것은, slow version K에서 inversion 하는 matrix 의 크기는 feature correspondences의 개수에 의존적이기 때문에, time cost 가 scene 마다 달라질 수 있다. 이는 특정 환경에서 발생한 적은 time cost만을 측정하여 자원의 upper bound 를 할당해두는 경우, 환경이 달라질 경우 문제가 될 수도 있다. 반면 fast version K는 항상 6x6 의 inversion을 수행하기 때문에, 소요되는 시간 역시 매 image 마다 유사함을 알 수 있다 (see the <a href="https://github.com/gisbi-kim/r2live/blob/859d0433f15b904239ec09424638eb35eb7339ae/r2live/src/estimator_node.cpp#L871">Timer::DumpIntoFile</a>, 평균이 아닌 모든 frames 에 대한 time cost 가 기록되어 있다).</li>
    </ul>
  </li>
</ol>

<h2 id="ps-재미난-사실들">PS. 재미난 사실들</h2>
<ol>
  <li>속도 개선: 극한의 깎기
    <ul>
      <li><a href="https://github.com/hku-mars/r2live/blob/e719ca266ab53ca8915ca4e1416152993f2a55d7/r2live/src/estimator_node.cpp#L688">r2live 코드를 보면</a>
        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_T_H</span> <span class="o">+</span> <span class="p">(</span><span class="n">state_aft_integration</span><span class="p">.</span><span class="n">cov</span> <span class="o">*</span> <span class="n">CAM_MEASUREMENT_COV</span><span class="p">).</span><span class="n">inverse</span><span class="p">()).</span><span class="n">inverse</span><span class="p">();</span>
<span class="n">K</span>   <span class="o">=</span> <span class="n">K_1</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="n">DIM_OF_STATES</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Hsub_T</span><span class="p">;</span>
</code></pre></div>        </div>
        <ul>
          <li>이 Kalman Gain 구현이 <a href="https://arxiv.org/abs/2010.08196">FAST-LIO</a>의 식20 에서 언급한 것과는 약간 다른 것을 볼 수 있다.</li>
          <li>즉 size 가 큰 $\textbf{R}$ matrix 를 생성조차 하지않고 scalar 값을 곱하는 것으로 대체하였다. 이는 each measurements in a single image (or a single lidar scan) 이 동일한 weight 를 가진다고 가정할 경우, $\textbf{R} = r\textbf{I}$ 와 같이 scaled identity 로 가정할 수 있다. 이 식을 원래 식 $ \textbf{K} = (\textbf{H}^{T}\textbf{R}^{-1}\textbf{H}+\textbf{P}^{-1})^{-1}\textbf{H}^{T}\textbf{R}^{-1}$ 에 대입하면 위의 코드와 같이 $\textbf{R}$ matrix 가 사라진 형태를 얻을 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>성능 개선: GICP 따라하기
    <ul>
      <li>FAST-LIO의 후속작은 FAST-LIO2 라기보다는(FAST-LIO2는 그냥 저널버전 느낌..), <a href="https://arxiv.org/pdf/2109.07082.pdf">VoxelMap</a> 이라고 생각한다.</li>
      <li>FAST-LIO에서는 단순한 point-to-plane loss (distance에 normal이 곱해짐) 을 사용하였다면, VoxelMap은 GICP-like Loss 를 사용하였다. 즉, per point 마다 다른 covariance 를 적용하였다. 재밌는 것은 구현이다. <a href="https://github.com/hku-mars/VoxelMap/blob/d787ee8ccfb0e509a36adb2c52bd5da97b29c39a/src/voxelMapping.cpp#L960">VoxelMap의 코드를 보면</a> r2live 의 fast-lio부분과 거의 동일한 코드베이스를 사용하고 있음을 알 수 있다. 대신 fast-lio (r2live) 와 달리 $\textbf{H}^{T}\textbf{R}^{-1}$을 명시적으로 계산해준다. 이 역시도 $\textbf{R}$을 별도로 만들어서 곱하는게 아니라 <code class="language-plaintext highlighter-rouge">MatrixXd Hsub_T_R_inv(6, effct_feat_num);</code> 와 같이 $\textbf{H}^{T}\textbf{R}^{-1}$ 라는 matrix 를 아예 처음부터 생성해서 다루고 있는 것도 재밌는 부분이다. 어쨌거나 VoxelMap에 와서는 per-point 마다 다른 weight 를 부여할 수 있게 되었고, 그 결과 아래 코드를 보면 <a href="https://arxiv.org/abs/2010.08196">FAST-LIO</a>의 식20 에서 언급한 fast kalman gain $ \textbf{K} = (\textbf{H}^{T}\textbf{R}^{-1}\textbf{H}+\textbf{P}^{-1})^{-1}\textbf{H}^{T}\textbf{R}^{-1}$ 과 이제 완벽히 format이 동일해진 것을 알 수 있다.</li>
    </ul>
    <p align="center">
   <img src="/assets/data/2022-11-26-fastlio-gain/voxelmap_k.png" width="650" />
 </p>
  </li>
</ol>

<h2 id="결론">결론</h2>
<ul>
  <li>FAST-LIO는 Kalman Gain의 형태를 조작함으로써 problem solving 시간 개선을 이루었다.</li>
  <li>기존의 잘 알려진 K가 항상 slow 한 것은 아니다. 하지만 low-level features의 geometric optimization 을 수행하는 SLAM 문제에서는, constraints 의 개수가 매우 많은 overdetermined system 이 일반적이며, 이 경우 K 계산이 slow 해지게 된다.</li>
  <li>그 현상을 좀 더 이해하기 쉽게 그림(matrix-illustrated)으로 그려보았다.</li>
  <li>그리고 실제로 그러한지 적용 전/후 실험을 수행해보았다.</li>
</ul>

  </div>

  <hr style="border:1px foo rgb(193, 198, 200)"><div id="disqus_thread" style="margin-top:25px"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://localhost:4000/slam/2022/11/27/fastlio-gain.html';
      this.page.identifier = 'http://localhost:4000/slam/2022/11/27/fastlio-gain.html';
    };
    (function () {
      var d = document, s = d.createElement('script');
      s.src = 'https://robotics.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
      powered by Disqus.</a></noscript></div>

    </section>
    <footer class="condensed">
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/assets/js/darkmode.js"></script>
  
  <script src="/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/assets/js/search.js"></script>
  
</body>

</html>
