<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/academicons-1.9.2/css/academicons.css">
<link rel="stylesheet" href="/assets/css/fontawesome-free-6.1.1-web/css/all.css">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">

<title>🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기</title>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기 | Giseop Kim Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기" />
<meta name="author" content="Giseop Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="SymForce 란? 최근 RSS 2022 에서 SymForce 라는 framework 이 공개되었다. Skydio 가 공개하였다. 내부적으로 5년동안 개발하고 실제로 사용해온 것이라고 한다. Skydio 는 초기에 GTSAM 저자이신 + SLAM 역사에 큰 획을 그은 Frank Dellaert 교수님의 자문을 받았다고 들었다. 최근에는 멋진 결과들도 보여주고 있어서, 이들의 기술력은 어떤 수준일지 궁금했었다. SymForce 논문을 보면 robotics (특히 드론 등)와 같이 빠른 계산이 실시간으로 요구될 때에는, (Ceres 같은) 계산그래프 기반보다 symbolic 기반 의 미분이 더 좋다고 주장하고 있다. 원래 Robotics 에서 Ceres 가 많이 쓰이고 있어서 새로운 solver 의 필요성을 못 느끼고 있었는데, 이 논문의 말을 들어보면 왠지 설득이 된다. 한 번 공부할겸 써보았다." />
<meta property="og:description" content="SymForce 란? 최근 RSS 2022 에서 SymForce 라는 framework 이 공개되었다. Skydio 가 공개하였다. 내부적으로 5년동안 개발하고 실제로 사용해온 것이라고 한다. Skydio 는 초기에 GTSAM 저자이신 + SLAM 역사에 큰 획을 그은 Frank Dellaert 교수님의 자문을 받았다고 들었다. 최근에는 멋진 결과들도 보여주고 있어서, 이들의 기술력은 어떤 수준일지 궁금했었다. SymForce 논문을 보면 robotics (특히 드론 등)와 같이 빠른 계산이 실시간으로 요구될 때에는, (Ceres 같은) 계산그래프 기반보다 symbolic 기반 의 미분이 더 좋다고 주장하고 있다. 원래 Robotics 에서 Ceres 가 많이 쓰이고 있어서 새로운 solver 의 필요성을 못 느끼고 있었는데, 이 논문의 말을 들어보면 왠지 설득이 된다. 한 번 공부할겸 써보았다." />
<link rel="canonical" href="http://localhost:4000/slam/2022/07/10/symforce_icp.html" />
<meta property="og:url" content="http://localhost:4000/slam/2022/07/10/symforce_icp.html" />
<meta property="og:site_name" content="Giseop Kim Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-10T06:03:36+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Giseop Kim"},"dateModified":"2022-07-10T06:03:36+09:00","datePublished":"2022-07-10T06:03:36+09:00","description":"SymForce 란? 최근 RSS 2022 에서 SymForce 라는 framework 이 공개되었다. Skydio 가 공개하였다. 내부적으로 5년동안 개발하고 실제로 사용해온 것이라고 한다. Skydio 는 초기에 GTSAM 저자이신 + SLAM 역사에 큰 획을 그은 Frank Dellaert 교수님의 자문을 받았다고 들었다. 최근에는 멋진 결과들도 보여주고 있어서, 이들의 기술력은 어떤 수준일지 궁금했었다. SymForce 논문을 보면 robotics (특히 드론 등)와 같이 빠른 계산이 실시간으로 요구될 때에는, (Ceres 같은) 계산그래프 기반보다 symbolic 기반 의 미분이 더 좋다고 주장하고 있다. 원래 Robotics 에서 Ceres 가 많이 쓰이고 있어서 새로운 solver 의 필요성을 못 느끼고 있었는데, 이 논문의 말을 들어보면 왠지 설득이 된다. 한 번 공부할겸 써보았다.","headline":"🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/slam/2022/07/10/symforce_icp.html"},"url":"http://localhost:4000/slam/2022/07/10/symforce_icp.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/assets/js/darkmode.js"></script>


<!-- fabicon -->
<link rel="icon" type="image/png" href="/assets/icon/me.png">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {
          equationNumbers: {
            autoNumber: "AMS"
          }
        },
        tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$'] ],
        processEscapes: true,
      }
    });
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
        alert("Math Processing Error: "+message[1]);
    });
</script>
<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    
</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header condensed">
      <div class="about-title">
      <a href="/">
        
        <img src="/assets/giseopkim_thermal.png" alt="Giseop Kim" />
        
      </a>
      <h2 id="title">
        <a href="/">Giseop Kim</a>
      </h2>
      </div><p class="tagline">SLAM Engineer</p></div>
      
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2023</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/slam/2022/07/10/symforce_icp.html">
    <h2 class="post-title">🌈 [SymForce Tutorial 1편] Nonlinear ICP 밑바닥부터 구현해보기</h2>
  </a>
  <hr style="border:1px foo rgb(193, 198, 200)">
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Jul 10, 2022</div><ul class="post-categories"><li>SLAM</li></ul></div>
  <div class="post">
    <!-- --- -->
<h1 id="symforce-란">SymForce 란?</h1>
<ul>
  <li>최근 RSS 2022 에서 <a href="https://symforce.org/" target="_blank">SymForce</a> 라는 framework 이 공개되었다. Skydio 가 공개하였다. 내부적으로 5년동안 개발하고 실제로 사용해온 것이라고 한다.</li>
  <li>Skydio 는 초기에 GTSAM 저자이신 + SLAM 역사에 큰 획을 그은 Frank Dellaert 교수님의 자문을 받았다고 들었다. 최근에는 <a href="https://youtu.be/ncZmnfIRIWE" target="_blank">멋진 결과들도 보여주고 있어서</a>, 이들의 기술력은 어떤 수준일지 궁금했었다.</li>
  <li><a href="https://arxiv.org/abs/2204.07889" target="_blank">SymForce 논문</a>을 보면 robotics (특히 드론 등)와 같이 빠른 계산이 실시간으로 요구될 때에는, (Ceres 같은) 계산그래프 기반보다 <strong>symbolic 기반</strong> 의 미분이 더 좋다고 주장하고 있다. 원래 Robotics 에서 Ceres 가 많이 쓰이고 있어서 새로운 solver 의 필요성을 못 느끼고 있었는데, 이 논문의 말을 들어보면 왠지 설득이 된다.</li>
  <li>한 번 공부할겸 써보았다.</li>
</ul>

<!-- --- -->
<h1 id="nonlinear-icp-구현하기">Nonlinear ICP 구현하기</h1>
<h2 id="목표">목표</h2>
<ul>
  <li>Nonlinear ICP 를 구현해보자.</li>
</ul>

<h2 id="배경지식">배경지식</h2>
<h3 id="nonlinear-optimization">Nonlinear optimization</h3>
<ul>
  <li>Nonlinear optimization 어쩌구 하면 <strong>== Gauss-Newton으로 iterative 하게 푼다</strong> 라고 이해해도 거의 무방하다.</li>
  <li>이 때 update step 의 방향과 크기를 계산하기 위해 cost function 의 미분값이 필요하고 이것을 Jacobian이라고 부른다.
    <ul>
      <li>이 때 cost function output dimension 이 $n$이고, cost function 을 구성하는 우리가 찾고싶은 최적값에 대한 파라미터 변수의 dimension 이 $m$이라고 하면 Jacobian의 shape 은 $n \times m$이 되게 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="auto-diff">Auto diff</h3>
<ul>
  <li>그런데 nonlinear한(즉 $a_0 x_0 + a_1 x_ 1 + …$ 형태가 아닌 모든 포맷) 복잡한 cost function 의 Jacobian 을 사람이 손으로 계산하는 것은 <a href="http://ceres-solver.org/automatic_derivatives.html#automatic-derivatives" target="_blank">실수할 위험이 크기 때문에</a>, 변수들을 계산그래프로 연결하고, 자동으로 미분값이 관리되도록 (전파되도록) 하는 구현을 채택하는 방식이 널리 쓰이고 있다 (e.g., Ceres, Pytorch)
    <ul>
      <li>이 경우, forward 전파될 때 하나의 변수에 대해 value와 gradient 의 두 값을 동시에 함께 저장해야 되게된다. 예를 들어, <a href="http://ceres-solver.org/automatic_derivatives.html#dual-numbers-jets" target="_blank">Ceres 에서는 jet</a>이라는 형태로 관리되고,  <a href="https://autodiff.github.io/#forward-mode" target="_blank">autodiff 에서는 dual</a> 이라는 이름이 쓰이고 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="symbolic-diff">Symbolic diff</h3>
<ul>
  <li>이렇게 jet, dual 등의 구조체로 두 값을 관리하면서 계산그래프를 형성하는 식의 autodiff 가 robotics 와 deep learning 분야 모두에 대해서 널리 쓰이고 있는 (Ceres, autodiff, tinyAD, jax, pytorch, tensorflow 등등등) 요즘이지만 …</li>
  <li>SymForce 는 Symbolic 기반이라고 한다. 즉, 임의의 cost function 이 주어질 때, 이것의 자코비안을 명시적으로 식으로 딱 계산해준다. 그리고 이 계산이 최적화되도록 해준다.
    <ul>
      <li>그리고 <a href="https://symforce.org/tutorials/codegen_tutorial.html" target="_blank">python 으로 수식을 적으면 c++ code 를 생성</a>해주기까지 한다!</li>
    </ul>
  </li>
  <li>예를 들어, ICP에서 cost function 은 다음과 같다. 3D point $p_0$ 과 point $p_1$이 주어질 때, loss $= ||\left( R \{ \theta \}*p_0 + t \right) - p_1 || _2$ 를 최소화하는 transformation parameter $\theta$ 와 $t$ 를 찾는 것이 목표이다.
    <ul>
      <li>이 때 자연스럽게 그러면 다음과 같은 질문(멘붕)에 빠지게 된다. $\frac{\partial\text{loss}}{\partial\bf{\theta}}$ 와 $\frac{\partial\text{loss}}{\partial{t}}$를 어떻게 계산하지 ..???!?</li>
      <li>이 때 이걸 계산그래프로 묶어서 값을 주면 autodiff 이고.. 명시적으로 (수작업 기준)복잡한 수식을 찾아주는 게 symbolic 이라고 일단 이해하고 있다 (더 공부 필요)</li>
      <li>즉, SymForce 에게 이 작업을 맡기면 $\frac{\partial\text{loss}}{\partial\bf{\theta}}$이 다음과 같이 아래 그림처럼 나온다 (너무 길어서 다 옮길 수가 없어서 캡처로 대신한다. 전체 식은 <a href="https://github.com/gisbi-kim/symforce-tutorials/blob/main/nonlinear_icp_from_scratch/symforce_icp.ipynb">여기 jupyter notebook</a>를 참고).
        <p align="center">
      <img src="/assets/data/2022-07-10-symforce_icp/jrot.png" width="1050" />
  </p>
      </li>
      <li>이 때 $\theta$는 rotation 을 minimal 하게 parametrize 하는 angle-axis 가 된다. 이를 tangent space 에서 최적화한다라고도 표현하고, 이후에 이 값을 원래 공간 (e.g., rotation에 대해서는 $\text{SO(3)}$) 으로 보내주는 작업을 retract 라고 부르기도 하고 … 이에 대해서는 별도의 rotation 관련 자료(<a href="https://arxiv.org/abs/1812.01537">A micro Lie theory for state estimation in robotics</a>, <a href="https://arxiv.org/abs/1711.02508">Quaternion kinematics for the error-state Kalman filter
</a>)를 참고하도록 하자.</li>
    </ul>
  </li>
  <li>아무튼 요약하자면 Jacobain matrix 의 값을 알면 iterative update 하는 것은 너무 쉬운데, 이 때 아무리 복잡한 함수여도 SymForce 가 자코비안을 알아서 잘 구해준다는 것. 특히 robotics 에서 많이 사용하는 parameter 들 (camera projection, rotation 등) 에 대한 지원을 포함하고 있기 때문에 SymPy 등의 기존 Symbolic solver 들을 사용할 때보다 robotics 문제를 더 풀기 편리해졌다는 점 등이 장점이라고 할 수 있겠다.</li>
</ul>

<h2 id="구현">구현</h2>

<p id="grisetti-tuto"> </p>
<h3 id="iterative-update">Iterative update</h3>
<ul>
  <li>자코비안을 구한다음, 이것을 이용해서 iterative 하게 최적의 $d[\theta, t]$ 를 구하고, 조금씩 이 값을 업데이트 해나가는 루틴은 너무나 자명하다. 이에 대해서는 Grisetti 교수님의 <a href="http://www.diag.uniroma1.it//~labrococo/tutorial_icra_2016/icra16_slam_tutorial_grisetti.pdf">2016년 ICRA tutorial 자료</a> 를 추천한다. 여기에 보면 이런 식이 있다. Octave (Matlab) 구현체이다.</li>
</ul>
<p align="center">
     <img src="/assets/data/2022-07-10-symforce_icp/gn_octave.png" width="650" />
</p>

<ul>
  <li>위의 구조를 python으로 옮기면 다음과 같이 된다. (전체 코드는 <a href="https://github.com/gisbi-kim/symforce-tutorials/tree/main/nonlinear_icp/1_nonlinear_icp_SE3">여기 symforce-tutorials</a> 서 볼 수 있다).
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">icp</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">tf_init</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

  <span class="n">tf</span> <span class="o">=</span> <span class="n">tf_init</span> <span class="c1"># 6 dim
</span>  <span class="n">num_pts</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
      <span class="c1"># reset for each iter
</span>      <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

      <span class="c1"># gathering measurements
</span>      <span class="k">for</span> <span class="n">pt_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>

          <span class="n">src_pt</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">pt_idx</span><span class="p">,</span> <span class="p">:]</span>
          <span class="n">tgt_pt</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="n">pt_idx</span><span class="p">,</span> <span class="p">:]</span>

          <span class="n">e</span><span class="p">,</span> <span class="n">Je_rot</span><span class="p">,</span> <span class="n">Je_trans</span> \
              <span class="o">=</span> <span class="n">evaluate_error_and_jacobian</span><span class="p">(</span><span class="n">src_pt</span><span class="p">,</span> <span class="n">tgt_pt</span><span class="p">,</span> <span class="n">tf</span><span class="p">)</span>

          <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Je_rot</span><span class="p">,</span> <span class="n">Je_trans</span><span class="p">))</span> <span class="c1"># thus, 3x6
</span>
          <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">J</span> <span class="c1"># H: 6x3 * 3x6 =&gt; thus H is 6x6
</span>          <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">e</span> <span class="c1"># b: 6x3 * 3x1 =&gt; thus b is 6x1
</span>
      <span class="n">dtf</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c1"># note the step direction is minus
</span>      <span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="n">dtf</span> <span class="c1"># updated within the tangent space
</span>
  <span class="k">return</span> <span class="n">tf</span>
</code></pre></div>    </div>
    <ul>
      <li>note: 이 때 <code class="language-plaintext highlighter-rouge">src_pt</code>와 <code class="language-plaintext highlighter-rouge">tgt_pt</code> 는 실제로 같은 지점의 포인트여야 한다. 즉, correspondence 여야 한다.
        <ul>
          <li>ps. 이번 튜토리얼은 교육용으로 작성해본 것 (1. SymForce를 이용해서 자동으로 Jacobian을 심볼릭 기반으로 계산해보기 2. 이를 이용해서 nonlinear optimization 의 update 부분 from scratch로 구현해보기) 이기 때문에… point cloud $\text{pcd}_0$(위의 리포에서 <code class="language-plaintext highlighter-rouge">data/251371071.pcd</code>를 로드하고 임의의 $\text{SE(3)}$ transformation 을 가해주어서 $\text{pcd}_1$ 을 생성하고 있다. 따라서 point 의 순서가 보존되므로 <code class="language-plaintext highlighter-rouge">src_pt</code>와 <code class="language-plaintext highlighter-rouge">tgt_pt</code> 모두 동일한 인덱스 <code class="language-plaintext highlighter-rouge">pt_idx</code> 로 가져오면 correspondence 가 성립된다. 실제 세계 문제에서는 <a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/fpfh_estimation.html">FPFH local feature</a> 등의 방법으로 correspondence 를 먼저 찾고, 잘 associate 된 pair 를 위의 icp 알고리즘에 넣어주어야 한다.</li>
        </ul>
      </li>
      <li>위의 루틴은 특별히 어려울 것은 없다. Robotics 문제에서 ICP뿐 아니라 어떤 알고리즘이 되더라도 결국 위의 모습을 하게 된다.</li>
      <li>이 때 그러면 위의 루틴에서 Jacobian을 계산해주는 <code class="language-plaintext highlighter-rouge">evaluate_error_and_jacobian</code> 함수를 디자인하는 것이 로보틱스 엔지니어의 역할이 된다. 그런데 그것을 이제 SymForce가 수행해준다. 아래 코드처럼 정의된 모델에 해당 데이터포인트에서의 값을 넣어주기만 하면된다. 이 역할을 하는 것이 SymForce 에서 <code class="language-plaintext highlighter-rouge">.subs</code> method 인데 substitution 을 의미한다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">evaluate_error_and_jacobian</span><span class="p">(</span><span class="n">src_pt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tag_pt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">transformation</span><span class="p">):</span>
  <span class="c1"># note: transformation is 6dim vector on the tangent space (i.e., [rotvec, trans])
</span>
      <span class="k">def</span> <span class="nf">inject_values</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
          <span class="n">model_evaluated</span> <span class="o">=</span> \
              <span class="n">model</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">rotvec</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">transformation</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span> \
                   <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">transvec</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="mi">3</span><span class="p">:]))</span> \
                   <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p_src</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">src_pt</span><span class="p">))</span> \
                   <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p_tgt</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">tag_pt</span><span class="p">))</span>
          <span class="k">return</span> <span class="n">model_evaluated</span>

      <span class="n">error</span> <span class="o">=</span> <span class="n">inject_values</span><span class="p">(</span><span class="n">error_model</span><span class="p">)</span>
      <span class="n">Je_rot</span> <span class="o">=</span> <span class="n">inject_values</span><span class="p">(</span><span class="n">Je_rot_model</span><span class="p">)</span>
      <span class="n">Je_trans</span> <span class="o">=</span> <span class="n">inject_values</span><span class="p">(</span><span class="n">Je_trans_model</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">error</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">Je_rot</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">Je_trans</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</code></pre></div>        </div>
      </li>
      <li>참고로 여기에 쓰이는 <code class="language-plaintext highlighter-rouge">error_model</code>, <code class="language-plaintext highlighter-rouge">Je_rot_model</code>, <code class="language-plaintext highlighter-rouge">Je_trans_model</code> 등은 아래 코드와 같이 편하게 생성할 수 있다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Model parameters (as symbolic)
</span>  <span class="n">transvec</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="s">"t"</span><span class="p">)</span>
  <span class="n">rotvec</span>   <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="s">"Theta"</span><span class="p">)</span> <span class="c1"># i.e., angle-axis parametrization
</span>  <span class="n">rotmat</span>   <span class="o">=</span> <span class="n">LieGroupOps</span><span class="o">.</span><span class="n">from_tangent</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Rot3</span><span class="p">,</span> <span class="n">rotvec</span><span class="p">)</span> <span class="c1"># for debug, display(rotmat.to_rotation_matrix())
</span>
  <span class="c1"># Redisual (loss function)
</span>  <span class="c1">#  note: the rotation 'matrix' is used to formulate the below constraint,
</span>  <span class="c1">#        but it was parametrized as a 3-dim vector 'rotvec'!
</span>  <span class="n">p_src</span>        <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="s">"p_src"</span><span class="p">)</span>     <span class="c1"># p means a single 3D point
</span>  <span class="n">p_tgt</span>        <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="s">"p_tgt"</span><span class="p">)</span>
  <span class="n">p_tgt_est</span>    <span class="o">=</span> <span class="p">(</span><span class="n">rotmat</span> <span class="o">*</span> <span class="n">p_src</span><span class="p">)</span> <span class="o">+</span> <span class="n">transvec</span> <span class="c1"># The constraint: R*p + t == p'
</span>
  <span class="n">error_val</span> <span class="o">=</span> <span class="n">p_tgt_est</span> <span class="o">-</span> <span class="n">p_tgt</span>

  <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="n">error_V3</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
          <span class="n">error_V3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_V3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">error_V3</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">error_V3</span>

  <span class="n">error_model</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">error_val</span><span class="p">)</span>

  <span class="c1"># residual jacobian
</span>  <span class="c1">#  this is the powerful moment of symforce. It automatically generate the Jacobian equations explicitly.
</span>  <span class="n">Je_trans_model</span> <span class="o">=</span> <span class="n">error_model</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">transvec</span><span class="p">)</span>
  <span class="n">Je_rot_model</span> <span class="o">=</span> <span class="n">error_model</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">rotvec</span><span class="p">)</span>
</code></pre></div>        </div>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">V3</code>등은 3 dimension vector 를 의미한다. 이렇듯 SymForce 에서 지원하는 symbolic class 로 변수를 잘 이어붙여서 error function 을 정의해주고, 여기에 <code class="language-plaintext highlighter-rouge">.jacobian(w.r.t what)</code> 라고만 해주면 준비 끝.
            <ul>
              <li>ps. 여기서 <code class="language-plaintext highlighter-rouge">rotvec</code>, <code class="language-plaintext highlighter-rouge">rotmat</code> 등의 차이에 대해 배경지식을 구비하기 위해서는 앞서도 이야기했지만 rotation 관련 자료(<a href="https://arxiv.org/abs/1812.01537">A micro Lie theory for state estimation in robotics</a>, <a href="https://arxiv.org/abs/1711.02508">Quaternion kinematics for the error-state Kalman filter</a>)를 참고하도록 하자.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="결과">결과</h3>

<ul>
  <li>그래서 <code class="language-plaintext highlighter-rouge">icp</code> 함수를 수행하면, 다음 결과(캡처)와 같이 임의로 처음에 가했던 transformation과 최적화해서 찾은 예측값이 동일함을 알 수 있다.
    <p align="center">
       <img src="/assets/data/2022-07-10-symforce_icp/result.png" width="650" />
  </p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">diff_SE3</code> 값을 달리해가면서 체험해보길 바란다! 그래도 늘 같은 값을 잘 예측하는 것을 알 수 있다.
        <ul>
          <li><a href="https://youtu.be/FG6bi5bAbTY">여기 유튜브 영상</a>에서 수렴과정을 시각화하였다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="결론">결론</h1>
<h2 id="요약">요약</h2>
<ol>
  <li>SymForce 는 로보틱스 문제를 풀 때 필요한 자코비안을 잘 생성해준다.</li>
  <li>Gauss-Newton pipeline 을 구성해볼 때 가장 애먹는 부분이 Jacobian 을 구하는 부분인데, 이 부분을 캡슐화하고 나니, nonliear update pipeline 을 구현하는 데 좀 더 집중하여 최적화 과정을 더 잘 파악해볼 수 있다.
    <ul>
      <li>전체 코드는 <a href="https://github.com/gisbi-kim/symforce-tutorials/blob/main/nonlinear_icp/1_nonlinear_icp_SE3/nonlinear_icp_SE3.ipynb">여기 (link)</a> 서 볼 수 있다</li>
      <li>ps. 복잡한 nonlinear cost 의 Jacobian 구하는 것부터 신경쓰게 되는 것은 입문자 입장에서 (수학적으로) 어렵다. 그렇다고 이를 회피하다 보면, 매번 너무 쉬운 예제만을 다루게 된다. 즉 로보틱스 실전 문제 중 항상 일부만 다루게 되거나 2D space 에 한정되므로 아쉽다.. (e.g., 2D에서의 differential wheel motion 등).</li>
    </ul>
  </li>
</ol>

<h2 id="todo"><a name="todo"></a>TODO</h2>
<ul>
  <li>공부삼아 Gauss-Newton update 과정을 구성해보았지만, 아마 optimizer 라는 class 로 이런 과정들이 이미 wrapping 되어있는 듯 하다. SymForce 가 제공하는 <a href="https://github.com/symforce-org/symforce#build-an-optimization-problem">조금 더 high-level에서의 optim API</a>를 사용해보자</li>
  <li>Cauchy kernel 을 씌워서 loss function 을 from scratch로 구현해보자. 그리고 noisy 한 correspondences pairs 가 주어졌을 때 robust kernel 여부에 따른 강건성 차이를 실습해보자. 그리고 <a href="https://symforce.org/search.html?q=gnc">GncOptimizer</a>도 사용해보자.</li>
  <li>Automatically generated C++ code 기준 Ceres 와의 속도차이를 실제로 테스트해보자.</li>
</ul>

<!-- --- -->

  </div>

  <hr style="border:1px foo rgb(193, 198, 200)"><div id="disqus_thread" style="margin-top:25px"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://localhost:4000/slam/2022/07/10/symforce_icp.html';
      this.page.identifier = 'http://localhost:4000/slam/2022/07/10/symforce_icp.html';
    };
    (function () {
      var d = document, s = d.createElement('script');
      s.src = 'https://robotics.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
      powered by Disqus.</a></noscript></div>

    </section>
    <footer class="condensed">
      <ul class="social about-footer condensed"><a href="https://www.linkedin.com/in/giseop-kim-71683088" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a><a href="https://scholar.google.com/citations?user=9mKOLX8AAAAJ&hl=ko&oi=ao" target="_blank">
          <li>
            <i class="ai ai-google-scholar"></i>
          </li>
        </a><a href="https://github.com/gisbi-kim" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://bit.ly/giseopkim" target="_blank">
          <li>
            <i class="fa fa-user" style="font-size: 2.09em;"></i>
            <!-- <i> notion</i> -->
            <!-- <i class="fa fa-user"></i> -->
          </li>
        </a><a href="https://youtube.com/channel/UCrmVMJ3KEFbDD9EtnAmDT6g" target="_blank">
          <li>
            <i class="icon-youtube"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2023</p><div class="about-footer condensed">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/assets/js/darkmode.js"></script>
  
  <script src="/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/assets/js/search.js"></script>
  
</body>

</html>
