---
layout: post
title:  "ğŸŒˆ SymForce ê¸°ë°˜ Pose-graph Optimization ì‹¤ìŠµ (Toy Example)"
date:   2022-07-31 03:00:00 +0000
categories: SLAM 
---

# Pose-graph optimization ì´ë€? 
- ê³„ì‚° íš¨ìœ¨ì„±ì„ ë†’ì´ê¸° ìœ„í•´ Landmark ë¥¼ state vector ì—ì„œ ì œì™¸í•˜ëŠ” ì‹œë„ë“¤ì´ 2000ë…„ëŒ€ í›„ë°˜ SLAM í•™ê³„ì—ì„œ ì´ì–´ì¡Œë‹¤. 
- ê·¸ë¦¬ê³  3D ì •ë³´ë¥¼ ì§ì ‘ ì •êµí•˜ê²Œ ì¸¡ì •í•˜ëŠ” LiDAR sensor ê°€ ëŒ€ì¤‘í™”ë˜ë©°, ambiguous landmarkë¥¼ êµ³ì´ ìµœì í™”í•  í•„ìš” ì—†ì´, ë¡œë´‡ì˜ poseë§Œì„ ìµœì í™” í•˜ëŠ” ê²ƒì´ ë”ìš± ëŒ€ì¤‘í™”ëœ ë“¯í•˜ë‹¤. 
- SymForce ë¥¼ ì´ìš©í•´ì„œ Pose-graph Optimizationì„ êµ¬í˜„í•´ë³´ì. 

## Why SymForce for PGO? 
- ì‚¬ì‹¤ Pose-graph optimization ì— ëŒ€í•´ì„œëŠ” GTSAMì—ì„œ ì´ë¯¸ ê·¸ ê¸°ëŠ¥ì„ (APIë„ ì“°ê¸° ì‰½ê²Œ) ë„ˆë¬´ ì˜ ì œê³µí•˜ê³  ìˆê¸° ë•Œë¬¸ì— ìƒˆë¡œìš´ libraryê°€ êµ³ì´ í•„ìš”í•´? ë¼ëŠ” ìƒê°ì´ ë“¤ê¸°ë„ í•œë‹¤. 
    - LIO-SAMì´ ê·¸ì¤‘ ê°€ì¥ ìœ ëª…í•œ GTSAMì„ PGOì— ì‚¬ìš©í•œ ì˜ˆì‹œì´ë‹¤ (ê±°ì˜ starë„ ì´ì œ 2ì²œê°œê°€ ë‹¤ ë˜ì–´ ê°„ë‹¤).
        - https://github.com/TixiaoShan/LIO-SAM ì—ì„œ `mapOptmization.cpp` ì„ ë³´ë©´ëœë‹¤. 
    - í•˜ì§€ë§Œ ë³´í†µ ì´ë ‡ê²Œ ë˜ë©´ ì—”ì§€ë‹ˆì–´ê°€ í• ì¼ì€ ë§¤ìš° ì¶”ìƒí™”ë˜ê²Œ ëœë‹¤. 
        1. `isam = new ISAM2(parameters);`ë¥¼ ì„ ì–¸í•˜ê³ , 
        2. `gtSAMgraph.add(some factor)` í•˜ê³ , 
        3. `isam->update(gtSAMgraph, initialEstimate);` í•˜ëŠ” ì‹ì´ë‹¤ ..
    - ê·¸ë˜ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‹¤ì œë¡œ ìµœì í™”ê°€ ì´ë£¨ì–´ì§€ëŠ”ì§€ ì–´ì§€ê°„í•œ ì—´ì •ì´ ì—†ìœ¼ë©´ ëª¨ë¥´ê³  ì“°ê²Œ ëœë‹¤. 
        - ë‚´ ì–˜ê¸°ë‹¤ ..
    - GTSAMì€ C++ì—ì„œ custom loss ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆì§€ë§Œ Ceresì— ë¹„í•´ ê³µê°œëœ êµ¬í˜„ì²´ë‚˜ docs ê°€ ì ì€ ëŠë‚Œì´ë‹¤. ê·¸ë˜ì„œ ê¸°ì¡´ built-in cost ë“¤ì˜ êµ¬í˜„ì„ í†ºì•„ë³´ë©° ë”°ë¼ ì‘ì„±í•´ì•¼ í–ˆê³  .. ê·¸ë¦¬ê³  ì™ ì§€ ë­”ê°€ ë‚´ë¶€êµ¬ì¡°ë¥¼ ì¢€ ì•Œê¸°ê°€ ì–´ë µë‹¤ëŠ” ì¸ìƒì´ ìˆì—ˆë‹¤. ë‚´ë¶€ì ìœ¼ë¡œëŠ” traits ê³¼ Template ìœ¼ë¡œ ë³µì¡í•˜ê²Œ ì§œì—¬ì ¸ìˆëŠ”ë° .. íŒŒì•…í•˜ê¸°ê°€ ì¢€ ë³µì¡í•˜ë‹¤. 
    - ë°˜ë©´ SymForceëŠ” Jacobian ì„ Symbolic í•˜ê²Œ ê³„ì‚°í•´ì„œ ë³´ì—¬ì£¼ë¯€ë¡œ ëª…í™•í•œ ì¸ìƒì´ ìˆë‹¤.. 
        - [ì•ì˜ ë¸”ë¡œê·¸ íŠœí† ë¦¬ì–¼]({{ site.baseurl }}{% post_url 2022-07-10-symforce_icp %}) ì—ì„œ Symforce ê°€ êµ¬í•´ì¤€ Jacobainì„ ê°€ì ¸ë‹¤ ì‚¬ìš©í•´ì„œ ì§ì ‘ Gauss-Newton iteration ì„ êµ¬ì„±í•´ë³¼ ìˆ˜ ìˆì—ˆë‹¤. 
        - ë¬´ì—‡ë³´ë‹¤ python ì—ì„œë„ custom loss ë¥¼ ì‰½ê²Œ ì‘ì„±í•  ìˆ˜ ìˆì–´ì„œ ì´ê²ƒì €ê²ƒ í•´ë³´ê¸°ê°€ ì¢‹ì€ë“¯ í•˜ë‹¤.  
    - ps. í•œí¸, GTSAM ì„ ì‚¬ìš©í•˜ëŠ” ê·¸ë£¹ì´ ëª‡ ìˆì—ˆê³ , ê·¸ ì™¸ì—ëŠ” ëŒ€ì²´ë¡œ Ceres ë¥¼ ë§ì´ë“¤ ì‚¬ìš©í•˜ëŠ” ë“¯í•˜ë‹¤. Ceres ë¡œ PGOë¥¼ êµ¬í˜„í•œ ê°€ì¥ ìœ ëª…í•œ ì‚¬ë¡€ëŠ” ì•„ë§ˆ VINS-monoì¼ ê²ƒì´ë‹¤. 
        - `https://github.com/HKUST-Aerial-Robotics/VINS-Mono/tree/master/pose_graph` ì—¬ê¸°ë¥¼ ë³´ë©´ëœë‹¤. 
- ê·¸ë˜ì„œ SymForce tutorial ì°¨ì›ì—ì„œ ì´ê²ƒì €ê²ƒ ì‘ì„±í•´ë³´ê³  ìˆë‹¤. 
    - Iterative optimizatinoì„ From scratch ë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ì§€ë‚œ í¬ìŠ¤íŒ…ì—ì„œ í•´ë³´ì•˜ê³ , <a href="{{ site.baseurl }}{% post_url 2022-07-10-symforce_icp %}#todo">ì•ì˜ ë¸”ë¡œê·¸ íŠœí† ë¦¬ì–¼ì˜ todo</a> ì—ì„œ ì–˜ê¸°í–ˆë“¯ SymForce ê°€ ì œê³µí•˜ëŠ” optimizer class ë¥¼ ì‚¬ìš©í•´ë³´ì. 
    - ê´€ë ¨ ì˜ˆì‹œëŠ” landmark ë¥¼ bearing measurement ë¡œ ì¸¡ì •í•´ì„œ global localization ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ [ê³µì‹readme ì—](https://github.com/symforce-org/symforce#solve-the-problem) ìˆë‹¤. 
    - PGOê°€ ë”± ìˆì§€ëŠ” ì•Šì€ë° ì–´ì§œí”¼ êµ¬ì¡°ëŠ” ë¹„ìŠ·í•˜ë‹ˆê¹Œ ì§ì ‘ ì‘ì„±í•´ë³´ì. 
    
## SymForceê¸°ë°˜ì˜ PGO êµ¬í˜„ 
- [ì—¬ê¸°ì— ì „ì²´ ì‹¤ìŠµ ì½”ë“œ](https://github.com/gisbi-kim/symforce-tutorials/blob/main/pgo/1_pgo3d_toy/pose_graph_opt_3d_toy.ipynb)ê°€ ìˆë‹¤. 

### Cost functions 
- PGOì—ì„œ ì‚¬ìš©í•˜ëŠ” cost function ì€ (ìµœì†Œí•œìœ¼ë¡œ) prior ì™€ odometry, loop closure ê°€ ìˆë‹¤. 
- SymForce ë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ëœë‹¤. 
    ```python
    eps = 0.000001

    def prior_residual(
            pose    : sf.Pose3, 
            pose_prior: sf.Pose3,
            diagonal_sigmas: sf.V6 
        ) -> sf.V6:

        tangent_error = pose.local_coordinates(pose_prior, epsilon=eps)
        return sfT.cast(sf.V6, sf.M.diag(diagonal_sigmas.to_flat_list()).inv() * sf.V6(tangent_error))

    def odometry_residual(
            pose_prev: sf.Pose3, 
            pose_next: sf.Pose3, 
            movement : sf.Pose3,
            diagonal_sigmas: sf.V6,
        ) -> sf.V6:
        
        # The original reference of the below lines 
        #  - see https://github.com/symforce-org/symforce/blob/main/symforce/examples/robot_3d_localization/robot_3d_localization.py#L63
        movement_predicted = pose_prev.inverse() * pose_next
        tangent_error = movement_predicted.local_coordinates(movement, epsilon=eps)
        return sfT.cast(sf.V6, sf.M.diag(diagonal_sigmas.to_flat_list()).inv() * sf.V6(tangent_error))

    def loop_residual(
            pose_prev: sf.Pose3, 
            pose_next: sf.Pose3, 
            movement : sf.Pose3,
            diagonal_sigmas: sf.V6,
        ) -> sf.V6:

        return odometry_residual(pose_prev, pose_next, movement, diagonal_sigmas)
    ```
- ì„¤ëª… 
    1. prior ëŠ” pose ì˜ SE(3)ì„ direct ë¡œ ì¶”ì •í•˜ëŠ” unary factor (ì¸ìˆ˜ê°€ í•˜ë‚˜ë§Œ ì“°ì¸ë‹¤ëŠ” ëœ») ì´ë‹¤. 
    2. odometry ëŠ” consecutive í•œ node ì‚¬ì´ì˜ motion ì„ ì œì•½í•œë‹¤. 
        - ë”°ë¼ì„œ pose $i$ ì™€ pose $i+1$ ì‚¬ì´ì˜ ì˜ˆì¸¡ëœ ê°’ (motion model) ì´ ì‹¤ì œë¡œ ì¸¡ì •ëœ ê°’ (measurement)ê³¼ ì¼ì¹˜ë˜ë„ë¡ pose $i$ì™€ $i+1$ ì˜ ìœ„ì¹˜ê°€ ì¡°ì •ëœë‹¤. 
            - ì´ëŸ° íŠ¹ì„± ë•Œë¬¸ì— GTSAMì—ì„œëŠ” ì´ë¥¼ between factor ë¼ê³  ì¹­í•˜ê¸°ë„ í•œë‹¤. 
        - ì¦‰, ë‘˜ ì‚¬ì´ì˜ relative í•œ ì œì•½ë§Œì„ ë§Œì¡±í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì— ë‘ ë…¸ë“œì˜ ì „ì—­ì ì¸ ìœ„ì¹˜ ìì²´ëŠ” ì–´ë””ì— ë†“ì—¬ìˆë“  ìƒê´€ì´ ì—†ê²Œ ëœë‹¤. 
            - ì˜ˆë¥¼ ë“¤ì–´, ë‘ ë…¸ë“œê°€ 1ê³¼ 2ì— ìˆì–´ë„ ê·¸ ì‚¬ì´ ê°„ê²©ì€ 1ì´ê³ , 2ì™€ 3ì— ìˆì–´ë„ ê·¸ ì‚¬ì´ ê°„ê²©ì€ 1ì´ë¯€ë¡œ ì—¬ì „íˆ ì œì•½ì„ ë§Œì¡±í•œë‹¤. 
            - ë”°ë¼ì„œ ìµœì†Œí•œì˜ prior ê°€ í•„ìš”í•˜ë©° ë³´í†µ SLAMì—ì„œëŠ” ì²« node ì— ì•„ì£¼ ê°•í•œ (==ë§¤ìš° ì‘ì€ covarianceë¥¼ ê°€ì§€ëŠ”) prior ì œì•½ì„ ê±¸ì–´ì£¼ê²Œ ëœë‹¤. 
            - í˜¹ì€ GPS ê°™ì€ ê°’ì„ ì‚¬ìš©í•˜ì—¬ ì „ì—­ì ì¸ ìœ„ì¹˜ë¥¼ ê³ ì •í•  ìˆ˜ë„ ìˆë‹¤. 
                - rotation ì •ë³´ê°€ ì—†ì´ translation (ì¦‰, lat, lng, altitude) ë§Œ ì‚¬ìš©ê°€ëŠ¥í•œ ê²½ìš°, í•˜ë‚˜ì˜ node ë§Œ prior ë¥¼ ê±¸ì–´ì£¼ëŠ” ê²ƒìœ¼ë¡œëŠ” ë¶€ì¡±í•˜ê³  ë‘˜ ì´ìƒì˜ ì„œë¡œ ë‹¤ë¥¸ ë…¸ë“œì— prior ë¥¼ ê±¸ì–´ì£¼ì–´ì•¼ global heading ì„ ì•Œ ìˆ˜ ìˆê²Œ ëœë‹¤.  
            - ps. ë§Œì•½ prior ë¥¼ ì•ˆê±¸ì–´ì£¼ë©´ ì´ ë…¸ë“œë“¤ì´ ëª¨ì–‘ìƒˆëŠ” ìœ ì§€í•˜ë©´ì„œ ì „ì—­ì ìœ¼ë¡œ ë¯¸ì³ë‚ ë›°ê²Œ (...) ë˜ëŠ”ë°, ì´ë¥¼ ê²Œì´ì§€ í”„ë¼ë¸”ëŸ¼ ì´ë¼ê³ ë„ í•˜ëŠ” ë“¯í•˜ë‹¤. [Ceres ì˜ ê³µì‹ example](https://ceres-solver.googlesource.com/ceres-solver/+/master/examples/slam/pose_graph_3d/pose_graph_3d.cc#89 ) ì—ì„œë„ ë”± ì´ ì´ì•¼ê¸°ê°€ ìˆë‹¤. 
                ```bash
              // The pose graph optimization problem has six DOFs that are not fully
              // constrained. This is typically referred to as gauge freedom. You can apply
              // a rigid body transformation to all the nodes and the optimization problem
              // will still have the exact same cost. The Levenberg-Marquardt algorithm has
              // internal damping which mitigates this issue, but it is better to properly
              // constrain the gauge freedom. This can be done by setting one of the poses
              // as constant so the optimizer cannot change it.
                ```
    3. loop closure ëŠ” not consecutive í•œ ë‘ node ì‚¬ì´ì˜ motionì„ ì œì•½í•œë‹¤. 
        - ë”°ë¼ì„œ ìˆ˜í•™ì ìœ¼ë¡œëŠ” odometry ì™€ ì™„ì „íˆ ë™ì¼í•˜ë‹¤. 
            - ê·¸ë˜ì„œ ìœ„ì˜ êµ¬í˜„ì—ì„œë„ `loop_residual` ì—ì„œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `odometry_residual` ì„ callí•˜ë„ë¡ êµ¬í˜„í•˜ì˜€ë‹¤. 
        - ë‹¤ë§Œ ë¶„ë¦¬í•´ì„œ ì´ì•¼ê¸°í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ì´ìœ ëŠ”, 
            - odometryì™€ loop closure ì—ëŠ” noise scale ì„ ë‹¤ë¥´ê²Œ ì ìš©í•˜ëŠ” ê²ƒì´ í˜„ì‹¤ ë¬¸ì œë¥¼ í’€ ë•Œì— ë„ì›€ì´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤. 
                - ì´ëŠ” ë³¸ì¸ì´ ì‚¬ìš©í•˜ëŠ” ì„¼ì„œì˜ í’ˆì§ˆì— ë”°ë¼ ë‹¬ë¦¬ ì ìš©í•´ì•¼ í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ odometryë¡œ wheel odometer ë¥¼ ì‚¬ìš©í•˜ëŠ”ë° ê·¸ê²ƒì˜ í’ˆì§ˆì´ ì¢‹ì§€ ì•Šë‹¤ë©´ odometry residualì— ëŒ€í•´ì„œëŠ” ë†’ì€ noise ë¥¼ ë¶€ì—¬í•  ìˆ˜ ìˆê² ë‹¤. ë°˜ë©´, ê³ ì •ë°€ì˜ lidar ì„¼ì„œ scan ì„ í†µí•´ loop closing ì„ ìˆ˜í–‰í•œë‹¤ë©´ loop closure residualì— ëŒ€í•´ì„œëŠ” ë‚®ì€ noise (==ë†’ì€ ì‹ ë¢°ë„) ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê² ë‹¤. 
            - ë˜í•œ loop closure factor ë¥¼ ì¶”ê°€í•˜ê¸° ì´ì „ì—, loop closure detection (or aka place recognition) ì´ë¼ëŠ” ê³¼ì •ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ”ë°, ì´ê²ƒì´ 100% í•­ìƒ ë§ì§€ê°€ ì•Šë‹¤. ë”°ë¼ì„œ odometry factor ì™€ ë‹¬ë¦¬ loop closure factor ì— ëŒ€í•´ì„œëŠ” robust kernel ì„ ì”Œì›Œì£¼ëŠ” ì‘ì—… ë“±ì´ ìš”êµ¬ë˜ê¸°ë„ í•œë‹¤. 
                - [ì—¬ê¸°ì—ì„œ GTSAMì˜ Cauchy kernel ì„ ì‚¬ìš©í•œ ì˜ˆì œ](https://github.com/gisbi-kim/SC-A-LOAM/blob/main/src/laserPosegraphOptimization.cpp#L298) ë¥¼ ì°¸ê³ ë°”ëŒ.  
        - ë”°ë¼ì„œ í”„ë™í‹°ì»¬í•˜ê²ŒëŠ” loop closure factor ì™€ odometry factor ë¥¼ ë¶„ë¦¬í•´ì„œ ìƒê°í•˜ëŠ” í¸ì´ ì¢‹ë‹¤.
- ì„¤ëª… 2 
    - ìœ„ì˜ ì½”ë“œë¥¼ ë³´ë©´ $\text{SE}(3)$ë¥¼ ì¸í’‹ìœ¼ë¡œ ë°›ì§€ë§Œ ì‹¤ì œë¡œ diffëŠ” local_coordinatesë¼ëŠ” í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ê³„ì‚°ë˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. 
        - SymForce ì˜ ì½”ë“œë¥¼ ëœ¯ì–´ë³´ë©´ Pose3ì— ëŒ€í•´ local_coordinates ì€ ì•„ë˜([ì›ë³¸ë§í¬](https://symforce.org/_modules/sym/ops/pose3/lie_group_ops.html#LieGroupOps.local_coordinates))ì™€ ê°™ì´ êµ¬í˜„ë˜ì–´ ìˆë‹¤. 
        ```python
            @staticmethod
            def local_coordinates(a, b, epsilon):
                # type: (sym.Pose3, sym.Pose3, float) -> T.List[float]

                # Total ops: 50

                # Input arrays
                _a = a.data
                _b = b.data

                # Intermediate terms (4)
                _tmp0 = -_a[0] * _b[0] - _a[1] * _b[1] - _a[2] * _b[2]
                _tmp1 = _a[3] * _b[3]
                _tmp2 = min(1 - epsilon, abs(_tmp0 - _tmp1))
                _tmp3 = (
                    2
                    * (2 * min(0, (0.0 if -_tmp0 + _tmp1 == 0 else math.copysign(1, -_tmp0 + _tmp1))) + 1)
                    * math.acos(_tmp2)
                    / math.sqrt(1 - _tmp2 ** 2)
                )

                # Output terms
                _res = [0.0] * 6
                _res[0] = _tmp3 * (-_a[0] * _b[3] - _a[1] * _b[2] + _a[2] * _b[1] + _a[3] * _b[0])
                _res[1] = _tmp3 * (_a[0] * _b[2] - _a[1] * _b[3] - _a[2] * _b[0] + _a[3] * _b[1])
                _res[2] = _tmp3 * (-_a[0] * _b[1] + _a[1] * _b[0] - _a[2] * _b[3] + _a[3] * _b[2])
                _res[3] = -_a[4] + _b[4]
                _res[4] = -_a[5] + _b[5]
                _res[5] = -_a[6] + _b[6]
                return _res
        ```
        - ì—¬ê¸°ì„œ return ê°’ì€ ë‘ Pose3ì¸ a, bì˜ difference ì´ë©° 3-4-5 ì¸ë±ìŠ¤ê°€ translation ì°¨ì´ì— í•´ë‹¹í•˜ê³ , 0-1-2 ì¸ë±ìŠ¤ê°€ rotation ì°¨ì´ì— í•´ë‹¹í•œë‹¤. 
            - ë§¤ë²ˆ ê²Œì‹œê¸€ì—ì„œ ì´ì•¼ê¸°í•˜ì§€ë§Œ rotation ì˜ minimal representationì€ 3-dim ì´ê¸° ë•Œë¬¸ì— ... 
                - ps. [Rotation ê³µë¶€ìë£Œ ì¶”ì²œì€ ì—¬ê¸°](https://gisbi-kim.github.io/blog/2021/10/03/slam-textbooks.html) ë¥¼ ì°¸ê³ ë°”ëŒ. 
        - `Total ops` ë¥¼ ëª…ê¸°í•œ ê²ƒë„ í¥ë¯¸ë¡œìš´ ë¶€ë¶„ì´ë‹¤. ì¦‰, ì € ì—°ì‚°ì´ Pose3ì— ëŒ€í•´ì„œ deterministic í•˜ê²Œ ìµœì í™”ë˜ì–´ ìˆë‹¤ëŠ” ëœ». 
    - ì•„ë¬´íŠ¼ ìš°ë¦¬ê°€ ì•Œì•„ì•¼ í•  ê²ƒ í•œì¤„ìš”ì•½ì€, rotation matrixì€ vector space ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì—, Pose3 (== $\text{SE}(3)$) type ì‚¬ì´ì˜ error ë¥¼ ê³„ì‚°í•˜ê³  ì‹¶ì„ ë•ŒëŠ” `local_coordinates` ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤. 
        - ps. ì§€ë‚œ from scratch ê²Œì‹œê¸€ì—ì„œëŠ” minimal í•œ vector3 ì¸ rotvecì„ ë¨¼ì € ì •ì˜í•˜ê³ , ì´ë¥¼ ì´ìš©í•´ì„œ SO(3)ì¸ rotmatì„ ë§Œë“¤ì–´ì„œ ì¼ì—ˆë‹¤. 
            ```python
              rotvec   = sf.V3.symbolic("Theta") # i.e., angle-axis parametrization
              rotmat   = LieGroupOps.from_tangent(sf.Rot3, rotvec) # for debug, display(rotmat.to_rotation_matrix())
            ```   

## Experiments Setting 
- ì•”íŠ¼ ì‚¬ì„¤ì´ ê¸¸ì—ˆëŠ”ë° ì‹¤í—˜ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 

### Dataset generation 
- ë¨¼ì € í† ì´ ë°ì´í„°ì…‹ì„ ì§ì ‘ ë§Œë“¤ì–´ë³´ì. ìì„¸í•œ ê±´ [ì½”ë“œë¥¼ ì°¸ê³ [(https://github.com/gisbi-kim/symforce-tutorials/blob/main/pgo/1_pgo3d_toy/pose_graph_opt_3d_toy.ipynb)ë°”ëŒ. 
- `move()` í•¨ìˆ˜ë¥¼ í†µí•´ ì •ë‹¤ê°í˜• ëª¨ì–‘ì˜ trajectoryë¥¼ êµ¬ì„±í•˜ëŠ” nê°œì˜ pose ë¥¼ ìƒì„±í•œë‹¤. ì˜ˆì‹œëŠ” ì•„ë˜ì™€ ê°™ë‹¤. 
<p align="center">
     <img src="/assets/data/2022-07-31-pgo-toy/toy_data.png" width="900"/>
</p>

### Hyper parameter setting 
- PGOì—ì„œ hyper parameter ë¼ê³  í•˜ë©´ ìœ„ì—ì„œ ì´ì•¼ê¸°í•œ 3ì¢…ë¥˜ì˜ factors ì— ëŒ€í•œ noise ë¥¼ ê²°ì •í•˜ëŠ” ì¼ì´ ë˜ê² ë‹¤. 
- ì´ ì˜ˆì œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±í•´ë³´ì•˜ë‹¤. 
    ```python
    ## noises 
    prior_diagonal_sigmas = np.array([0.001, 0.001, 0.001, 0.01, 0.01, 0.01]) * 0.001
    odometry_diagonal_sigmas = np.array([0.05, 0.05, 0.05, 0.1, 0.1, 0.1]) 
    loop_diagonal_sigmas = odometry_diagonal_sigmas * 0.1
    ```
1. prior ì˜ ê²½ìš° ì–´ì§œí”¼ ì œì¼ ì²« ë…¸ë“œì—ë§Œ ë¶€ì—¬í•  ê²ƒì´ë©°, ì „ì²´ trajectory ê°€ í”ë“¤ë¦¬ì§€ ì•Šì•„ì•¼ í•˜ë¯€ë¡œ (==gauge problemì— ë¹ ì§€ì§€ ì•Šì•„ì•¼ í•˜ë¯€ë¡œ) ì•„ì£¼ ì‘ì€ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ì˜€ë‹¤. 
2. odometry ëŠ” ì ë‹¹í•œ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ì˜€ë‹¤. 
        - ps. ì´ ë•Œ ì´ ê°’ì€ stdì¼ìˆ˜ë„ ìˆê³  covariance (stdì˜ ì œê³±) ì¼ìˆ˜ë„ ìˆëŠ”ë°, libraryë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¬¸ë§¥ìƒ íŒŒì•…í•˜ì—¬ì•¼ í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ GTSAMì—ì„œëŠ” covariance ì´ë‹¤. 
            - í•˜ì§€ë§Œ ê·¸ê²ƒë³´ë‹¤ ë” ì¤‘ìš”í•œ ê±´ ì–´ì§œí”¼ ì ì • ìŠ¤ì¼€ì¼ì€ ì‹¤í—˜ì ìœ¼ë¡œë„ íŒŒì•…í•˜ëŠ” ê²ƒì´ ìš”êµ¬ëœë‹¤. 
            - ì´ ì˜ˆì œì—ì„œëŠ” ì•ì„œ `sfT.cast(sf.V6, sf.M.diag(diagonal_sigmas.to_flat_list()).inv() * sf.V6(tangent_error))` ì™€ ê°™ì´ error ì— noise ì˜ inverse ë¥¼ ë°”ë¡œ ê³±í•´ì£¼ëŠ” í˜•íƒœë¡œ êµ¬í˜„ë˜ì—ˆë‹¤. 
                - ì¦‰, stdê°€ ëœë‹¤. ì•„ë˜ ìˆ˜ì‹ì„ ì°¸ê³ í•˜ë©´ ì´í•´ê°€ ëœë‹¤. (ì¶œì²˜: Factor Graphs for Robot Perception, 2017). error $e$ì— ë°”ë¡œ (ì—­ìˆ˜ê°€)ê³±í•´ì§€ëŠ” ê²ƒì€ covariance ì˜ sqrtì„ì„ ì•Œ ìˆ˜ ìˆë‹¤. ê·¸ë˜ì„œ ì•ì„œ êµ¬í˜„ì—ì„œë„ ë³€ìˆ˜ ì´ë¦„ì„ diagonal_`sigma` ë¼ê³  ì¹­í•´ë‘ì—ˆë‹¤.  
        <p align="center">
            <img src="/assets/data/2022-07-31-pgo-toy/cov_eq.png" width="700"/>
        </p>
3. loop closure ì˜ noise ëŠ” odometryë³´ë‹¤ ë” ì‘ê²Œ (ë” ê°•ë ¥í•˜ê²Œ ì‘ìš©í•˜ë„ë¡) ì„¤ì •í•˜ì˜€ë‹¤. 



### Key-based Value Management 
- SymForce ê°€ ë˜ ì¢‹ì€ ì ì´ ë°”ë¡œ Key ê¸°ë°˜ìœ¼ë¡œ value ë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ë‹¤. 
- factorsë“¤ì„ ì‹¤ì œë¡œ ì„ ì–¸í•  ë•Œ ë‹¤ìŒê³¼ ê°™ì´ í•˜ë©´ ëœë‹¤. 

```python
# 1/ Prior factors 
if use_factors['prior']:
    for i in range(num_poses):
        if i not in [0]:
            continue        
        # only add at the first node 
        factors.append(Factor(
            residual=prior_residual,
            keys=[f"poses[{i}]", f"poses_prior[{i}]", f"prior_diagonal_sigmas"],
        ))

# 2/ Odometry factors
if use_factors['odometry']:        
    for i in range(num_poses-1):        
        factors.append(Factor(
            residual=odometry_residual,
            keys=[f"poses[{i}]", f"poses[{i+1}]", f"odoms[{i}]", "odometry_diagonal_sigmas"],
        ))

# 3/ Loop factors
if use_factors['loop']:
    for ii, loops_index_pair in enumerate(loops_indexes):        
        idx_from = loops_index_pair[0]
        idx_to = loops_index_pair[1]
        factors.append(Factor(
            residual=odometry_residual,
            keys=[f"poses[{idx_from}]", f"poses[{idx_to}]", f"loops[{ii}]", "loop_diagonal_sigmas"],
        ))
```

- ìœ„ì˜ ì½”ë“œì—ì„œ ë³´ë‹¤ì‹œí”¼, `residual=`ì— í•¨ìˆ˜ë¥¼ ì…ë ¥í•´ì£¼ê³ , `keys=` ì— ì´ í•¨ìˆ˜ì— ì¸ìë¡œ ë“¤ì–´ê°ˆ ë³€ìˆ˜ë“¤ì„ ì°¨ë¡€ë¡œ ë‚˜ì—´í•´ì£¼ë©´ ëœë‹¤. 
    - ê·¸ëŸ°ë° ì´ stringfiedëœ ë³€ìˆ˜ì´ë¦„ë“¤ì€ ì–´ë””ì— ìˆëŠ”ê°€? ë‹¤ìŒê³¼ ê°™ì´ Values ë¼ëŠ” ê³³ì—ë‹¤ê°€ ë‹¤ ë‹´ì•„ì£¼ë©´ ëœë‹¤. 
    ```python
        initial_values = Values(
            # poses=[sf.Pose3.identity()] * num_poses, # may not converge.
            poses=initial_poses,
            
            poses_prior=poses_prior,
            prior_diagonal_sigmas=prior_diagonal_sigmas,

            odoms=odoms_obs,
            odometry_diagonal_sigmas=odometry_diagonal_sigmas,
            
            loops=loops_obs,
            loop_diagonal_sigmas=loop_diagonal_sigmas,
        )
    ``` 
        - ìš°ë³€ì— ìˆëŠ” ê²ƒì´ ìš°ë¦¬ê°€ ì‚¬ì „ì— ì •ì˜í•´ë‘” ë³€ìˆ˜ë“¤ì´ë©° 
        - ì¢Œë³€ì— ì‚¬ìš©í•œ ì´ë¦„ì´ keyë¡œ ì“°ì´ê²Œ ëœë‹¤.  

- ê·¸ëŸ¬ë©´ ìµœì¢…ì ìœ¼ë¡œ `Optimizer` classë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì‰½ë‹¤. ì•„ë˜ì™€ ê°™ì´ í•´ì£¼ë©´ ë!
```python
optimizer = Optimizer(
    factors=factors,
    optimized_keys=[f"poses[{i}]" for i in range(num_poses)],
    debug_stats=True,
)
``` 
    - ì—¬ê¸°ì„œëŠ” ìµœì í™”í•  ë³€ìˆ˜ì— ëŒ€í•œ keyë§Œ ë˜ ë„£ì–´ì£¼ê²Œ ë˜ëŠ”ë°, ì´ ë¶€ë¶„ì€ ì¢€ Pytorchì™€ ë‹®ì€ ê²ƒ ê°™ê¸°ë„ í•˜ë‹¤. 

## Results 
- ì‚¬ì„¤ì´ ë˜ ì—­ì‹œ ê¸¸ì—ˆëŠ”ë°, ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

### Without a Loop constraint 
- odometry factors ì— ëŒ€í•´ ground-truth ëŒ€ë¹„ perturbation noise ë¥¼ ì„ì–´ì£¼ì—ˆê¸° ë•Œë¬¸ì— (see `perturb_alpha` in the codes), loop closure factor ì—†ì´ëŠ” ì•„ë˜ì™€ ê°™ì´ trajectoryì— drift ê°€ ëˆ„ì ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤. 
<p align="center">
     <img src="/assets/data/2022-07-31-pgo-toy/result_odom.png" width="500"/>
</p>


### With only a single Loop constraint 
- í•œí¸, ì²˜ìŒ ë…¸ë“œì™€ ë§ˆì§€ë§‰ ë…¸ë“œ ì‚¬ì´ì— loop closure factor ë¥¼ ë‹¨ í•˜ë‚˜ë§Œ ë„£ì–´ì£¼ë”ë¼ë„, ì•„ë˜ì™€ ê°™ì´ ì „ì²´ trajectoryì˜ shape ì´ ë§ì´ ê°œì„ ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤. 
<p align="center">
     <img src="/assets/data/2022-07-31-pgo-toy/result_lc.png" width="500"/>
</p>

- ì‚¬ì‹¤ ìˆ˜í•™ì ìœ¼ë¡œ ë‹¹ì—°í•œ ê²°ê³¼ì´ë‹¤ã…ã… ê·¸ë˜ë„ ìƒˆë¡œìš´ íˆ´ì„ ì´ìš©í•´ì„œ ê°„ë‹¨í•˜ê²Œ ì´ë ‡ê²Œ ì‹¤ìŠµí•´ë³´ëŠ” ê²ƒì€ ì°¸ ì¬ë¯¸ìˆë‹¤. 
    - ì´ëŸ° ë¥˜ì˜ (ê½¤ ì‘ì€ ì½”ë“œë² ì´ìŠ¤ ê·œëª¨ì˜) PGO ëŠ” SLAMê³„ì˜ hello-world ë¼ê³  í•  ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? 

# ê²°ë¡  
- SymForce ë¡œ Pose-graph Optimization ì„ ìˆ˜í–‰í•´ë³´ì•˜ë‹¤. 
    - Pose3 ë“¤ì— ëŒ€í•´ unary (prior factor) or binary (between factor) constraints ë¥¼ ê±¸ì–´ì£¼ê¸° ìœ„í•´ì„œ, measurement ì™€ estimated (direct value or error value) ì‚¬ì´ì— error ë¥¼ ê³„ì‚°í•´ì•¼ í•œë‹¤. ì´ë¥¼ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œ local_coordinates ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤. ì´ëŸ° í”„ë¡œì„¸ìŠ¤ë¥¼ `tangent space optimization` ë¼ê³ ë„ ë¶€ë¥¸ë‹¤. 
- ps. ê·¸ ì™¸ì—.. simularity ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ epsilonì„ ì˜ ì‚¬ìš©í•´ì£¼ì–´ì•¼ í•œë‹¤. 

## TODO
- ì§ì ‘ ì œì‘í•œ toy example ì— ëŒ€í•´ì„œ í•´ë³´ì•˜ìœ¼ë‹ˆ, [SLAM ë…¼ë¬¸ë“¤ì—ì„œ ë§ì´ ì“°ì´ëŠ” ë°ì´í„°ì…‹](https://lucacarlone.mit.edu/datasets/) ì— ëŒ€í•´ì„œë„ ì‹¤í—˜ì„ í•´ë³´ì. 
    - ì´ ë•Œ ì˜ëª»ëœ (ì‚¬ì‹¤ì€ loopê°€ ì•„ë‹Œë°) loop closure factors ë“¤ì´ ë§ì´ ì‚½ì…ë  ë•Œ, ì–´ë–»ê²Œ ë°©ì–´í•  ìˆ˜ ìˆëŠ”ì§€ ì•Œì•„ë³´ì. 
    
        



